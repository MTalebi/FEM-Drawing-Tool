<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structural FEM Tool</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 300px;
            background: #e6e6e6;
            padding: 10px;
            overflow-y: auto;
        }
        .canvas-container {
            flex: 1;
            background: #fff;
            position: relative;
        }
        canvas {
            border: 1px solid #ccc;
            touch-action: none; /* Allows pinch, pan logic in JS */
        }
        h2 {
            margin-top: 0;
        }
        .section {
            margin-top: 10px;
        }
        button {
            margin-right: 5px;
            margin-top: 5px;
        }
        input[type="number"] {
            width: 80px;
        }
        .faded {
            opacity: 0.3;
        }
        .summary {
            margin-top: 10px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }

        /* Zoom/Home button styling in top-right */
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.8);
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 5px;
        }
        .zoom-controls button {
            margin: 5px 8px 5px 0;
            font-size: 16px;
            cursor: pointer;
        }

        /* Use 25%/75% layout on narrow screens */
        @media (max-width: 600px) {
            .sidebar {
                width: 25vw;
                min-width: 25vw;
            }
            .canvas-container {
                width: 75vw;
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left panel -->
        <div class="sidebar">
            <h2>Structural FEM Tool</h2>
            <p><em>By: Mohammad Talebi-Kalaleh</em></p>

            <!-- Mode selection -->
            <div class="section">
                <strong>Mode</strong>
                <div>
                    <label><input type="radio" name="mode" value="node" checked> Node</label><br>
                    <label><input type="radio" name="mode" value="member"> Member</label><br>
                    <label><input type="radio" name="mode" value="support"> Support</label><br>
                    <label><input type="radio" name="mode" value="load"> Load</label><br>
                </div>
            </div>
            
            <!-- Member Type -->
            <div class="section member-options">
                <strong>Member Type</strong>
                <div>
                    <label><input type="radio" name="memType" value="beam" checked> Beam</label><br>
                    <label><input type="radio" name="memType" value="truss"> Truss</label><br>
                </div>
            </div>
            
            <!-- Support Type -->
            <div class="section support-options">
                <strong>Support Type</strong>
                <div>
                    <label><input type="radio" name="supportType" value="fixed" checked> Fixed</label><br>
                    <label><input type="radio" name="supportType" value="roller_x"> Roller-X</label><br>
                    <label><input type="radio" name="supportType" value="roller_y"> Roller-Y</label><br>
                    <label><input type="radio" name="supportType" value="hinge"> Hinge</label><br>
                </div>
            </div>
            
            <!-- Load Settings -->
            <div class="section load-options">
                <strong>Load Settings</strong>
                <div>
                    <div>
                        <label><input type="radio" name="loadType" value="point" checked> Point</label><br>
                        <label><input type="radio" name="loadType" value="uniform"> Uniform</label><br>
                        <label><input type="radio" name="loadType" value="nonuniform"> Nonuniform</label><br>
                    </div>
                    <div>
                        <label><input type="radio" name="loadDir" value="x"> X</label><br>
                        <label><input type="radio" name="loadDir" value="y" checked> Y</label><br>
                    </div>
                    
                    <!-- Uniform Load Value -->
                    <div id="uniform-load-value">
                        <label>Load Value:</label><br>
                        <input type="number" id="loadValue" value="-1000"><br>
                    </div>
                    
                    <!-- Nonuniform Load Values -->
                    <div id="nonuniform-load-values" style="display: none;">
                        <label>Start Value:</label><br>
                        <input type="number" id="nuStartVal" value="-1000"><br>
                        <label>End Value:</label><br>
                        <input type="number" id="nuEndVal" value="-500"><br>
                    </div>
                </div>
            </div>
            
            <!-- Grid Settings -->
            <div class="section">
                <strong>Grid Settings</strong><br>
                <label><input type="checkbox" id="isSnap" checked> Grid Snap</label><br>
                <label>Grid spacing (meters):</label><br>
                <select id="gridSpacingSelect">
                    <option value="0.1">0.1 m</option>
                    <option value="0.5">0.5 m</option>
                    <option value="1" selected>1 m</option>
                    <option value="5">5 m</option>
                </select>
            </div>
            
            <!-- Buttons -->
            <div class="section">
                <button id="undoBtn">Undo</button>
                <button id="clearBtn">Clear All</button>
                <button id="saveBtn">Save Model</button>
            </div>
            
            <!-- Summary -->
            <div class="summary">
                <strong>Model Summary</strong>
                <div id="model-stats">
                    Nodes: 0<br>
                    Members: 0<br>
                    Supports: 0<br>
                    Loads: 0
                </div>
            </div>
        </div>
        
        <!-- Canvas area -->
        <div class="canvas-container">
            <canvas id="femCanvas"></canvas>

            <!-- Zoom/Home UI in top-right -->
            <div class="zoom-controls">
                <button id="zoomInBtn">+</button>
                <button id="zoomOutBtn">-</button>
                <button id="homeBtn">&#8962;</button>
            </div>
        </div>
    </div>

    <script>
        // Main model data
        const model = {
            nodes: {},
            members: {},
            supports: {},
            loads: {},
            nodeCounter: 0,
            memberCounter: 0,
            loadCounter: 0
        };

        // Configuration
        const config = {
            mode: "node",
            memberType: "beam",
            supportType: "fixed",
            loadType: "point",
            loadDir: "y",
            loadValue: -1000,
            nuStartVal: -1000,
            nuEndVal: -500,
            isSnap: true,
            gridSpacing: 1,     // minor grid spacing = 1 by default
            scaleFactor: 30,
            originX: 0,          // bottom-left
            originY: 0
        };

        let tempSelectedNode = null;
        let maxMemberLength = 0;

        // History stack
        const history = [];
        const maxHistory = 50;

        // Canvas and context
        const canvas = document.getElementById('femCanvas');
        const ctx = canvas.getContext('2d');

        // Cursor coords (screen space)
        let cursorX = 0;
        let cursorY = 0;

        // Desktop left-drag panning
        let isLeftClickDown = false;
        let desktopStartX = 0, desktopStartY = 0;
        let desktopHasPanned = false;
        const DESKTOP_MOVE_THRESHOLD = 10;
        let lastDesktopPanX = 0, lastDesktopPanY = 0;

        // Mobile single-finger panning
        let touchStartX = 0, touchStartY = 0;
        let isSingleFingerPanning = false;
        let hasMovedSignificantly = false;
        const MOVE_THRESHOLD = 10;
        let touchWentToMultiFinger = false;

        // Pinch zoom
        let isPinchZooming = false;
        let lastPinchDist = 0;
        let lastPinchCenter = { x: 0, y: 0 };

        function resizeCanvas() {
            if (window.innerWidth <= 600) {
                canvas.width = window.innerWidth * 0.75;
            } else {
                canvas.width = window.innerWidth - 300;
            }
            canvas.height = window.innerHeight;

            // Put origin at bottom-left corner
            config.originX = 50;
            config.originY = canvas.height - 50;

            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Zoom / Home
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const homeBtn = document.getElementById('homeBtn');

        zoomInBtn.addEventListener('click', () => {
            zoomAboutCenter(1.2);
        });
        zoomOutBtn.addEventListener('click', () => {
            zoomAboutCenter(0.8);
        });
        homeBtn.addEventListener('click', () => {
            config.scaleFactor = 30;
            config.originX = 0;
            config.originY = canvas.height;
            draw();
        });

        function zoomAboutCenter(scale) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const modelBefore = screenToModel(centerX, centerY);

            config.scaleFactor *= scale;
            config.scaleFactor = Math.max(5, Math.min(500, config.scaleFactor));

            const screenAfter = modelToScreen(modelBefore.x, modelBefore.y);
            config.originX += (centerX - screenAfter.x);
            config.originY += (centerY - screenAfter.y);

            draw();
        }

        // Sidebar references
        const modeRadios = document.querySelectorAll('input[name="mode"]');
        const memberTypeRadios = document.querySelectorAll('input[name="memType"]');
        const supportTypeRadios = document.querySelectorAll('input[name="supportType"]');
        const loadTypeRadios = document.querySelectorAll('input[name="loadType"]');
        const loadDirRadios = document.querySelectorAll('input[name="loadDir"]');
        const loadValueInput = document.getElementById('loadValue');
        const nuStartValInput = document.getElementById('nuStartVal');
        const nuEndValInput = document.getElementById('nuEndVal');
        const uniformLoadValueDiv = document.getElementById('uniform-load-value');
        const nonuniformLoadValuesDiv = document.getElementById('nonuniform-load-values');
        const isSnapCheckbox = document.getElementById('isSnap');
        const gridSpacingSelect = document.getElementById('gridSpacingSelect');
        const undoBtn = document.getElementById('undoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const modelStats = document.getElementById('model-stats');

        function updateOptionsVisibility() {
            document.querySelector('.member-options > div').classList.toggle('faded', config.mode !== 'member');
            document.querySelector('.support-options > div').classList.toggle('faded', config.mode !== 'support');
            document.querySelector('.load-options > div').classList.toggle('faded', config.mode !== 'load');
            
            document.querySelectorAll('.member-options input').forEach(i => i.disabled = (config.mode !== 'member'));
            document.querySelectorAll('.support-options input').forEach(i => i.disabled = (config.mode !== 'support'));
            document.querySelectorAll('.load-options input').forEach(i => i.disabled = (config.mode !== 'load'));
            
            if (config.loadType === 'nonuniform') {
                uniformLoadValueDiv.style.display = 'none';
                nonuniformLoadValuesDiv.style.display = 'block';
            } else {
                uniformLoadValueDiv.style.display = 'block';
                nonuniformLoadValuesDiv.style.display = 'none';
            }
        }
        updateOptionsVisibility();

        modeRadios.forEach(r => {
            r.addEventListener('change', () => {
                if (r.checked) {
                    config.mode = r.value;
                    updateOptionsVisibility();
                }
            });
        });
        memberTypeRadios.forEach(r => {
            r.addEventListener('change', () => {
                if (r.checked) config.memberType = r.value;
            });
        });
        supportTypeRadios.forEach(r => {
            r.addEventListener('change', () => {
                if (r.checked) config.supportType = r.value;
            });
        });
        loadTypeRadios.forEach(r => {
            r.addEventListener('change', () => {
                if (r.checked) {
                    config.loadType = r.value;
                    updateOptionsVisibility();
                }
            });
        });
        loadDirRadios.forEach(r => {
            r.addEventListener('change', () => {
                if (r.checked) config.loadDir = r.value;
            });
        });

        loadValueInput.addEventListener('change', () => {
            config.loadValue = parseFloat(loadValueInput.value) || -1000;
        });
        nuStartValInput.addEventListener('change', () => {
            config.nuStartVal = parseFloat(nuStartValInput.value) || -1000;
        });
        nuEndValInput.addEventListener('change', () => {
            config.nuEndVal = parseFloat(nuEndValInput.value) || -500;
        });

        isSnapCheckbox.addEventListener('change', () => {
            config.isSnap = isSnapCheckbox.checked;
            draw();
        });
        gridSpacingSelect.addEventListener('change', () => {
            const val = parseFloat(gridSpacingSelect.value);
            if (!isNaN(val) && val > 0) {
                config.gridSpacing = val;
                draw();
            }
        });

        undoBtn.addEventListener('click', handleUndo);
        clearBtn.addEventListener('click', handleClear);
        saveBtn.addEventListener('click', handleSave);

        // Prevent default context menu
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Desktop left-drag panning
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isLeftClickDown = true;
                desktopStartX = e.clientX;
                desktopStartY = e.clientY;
                desktopHasPanned = false;
                lastDesktopPanX = e.clientX;
                lastDesktopPanY = e.clientY;
            }
        });
        document.addEventListener('mouseup', (e) => {
            if (e.button === 0 && isLeftClickDown) {
                if (!desktopHasPanned && !isPinchZooming && !isSingleFingerPanning) {
                    const rect = canvas.getBoundingClientRect();
                    const px = e.clientX - rect.left;
                    const py = e.clientY - rect.top;
                    handleCanvasClick(px, py);
                }
                isLeftClickDown = false;
            }
        });
        canvas.addEventListener('mousemove', (e) => {
            if (isLeftClickDown) {
                const dx = e.clientX - desktopStartX;
                const dy = e.clientY - desktopStartY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > DESKTOP_MOVE_THRESHOLD) {
                    desktopHasPanned = true;
                    const ddx = e.clientX - lastDesktopPanX;
                    const ddy = e.clientY - lastDesktopPanY;
                    config.originX += ddx;
                    config.originY += ddy;
                    lastDesktopPanX = e.clientX;
                    lastDesktopPanY = e.clientY;
                    draw();
                }
            } else {
                const rect = canvas.getBoundingClientRect();
                cursorX = e.clientX - rect.left;
                cursorY = e.clientY - rect.top;
                draw();
            }
        });

        // Mobile pinch/finger logic
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                isSingleFingerPanning = false;
                hasMovedSignificantly = false;
                touchWentToMultiFinger = false;
                const t = e.touches[0];
                touchStartX = t.clientX;
                touchStartY = t.clientY;
            }
            if (e.touches.length === 2) {
                isPinchZooming = true;
                lastPinchDist = getPinchDistance(e.touches);
                lastPinchCenter = getTouchCenter(e.touches);
                touchWentToMultiFinger = true;
            }
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isPinchZooming && e.touches.length === 2) {
                const newDist = getPinchDistance(e.touches);
                const center = getTouchCenter(e.touches);
                const ratio = newDist / lastPinchDist;
                pinchZoom(ratio, center);
                lastPinchDist = newDist;
                lastPinchCenter = center;
                return;
            }
            if (e.touches.length === 1) {
                const t = e.touches[0];
                const dx = t.clientX - touchStartX;
                const dy = t.clientY - touchStartY;
                if (Math.sqrt(dx*dx + dy*dy) > MOVE_THRESHOLD) {
                    if (!isSingleFingerPanning) {
                        isSingleFingerPanning = true;
                        lastPanX = t.clientX;
                        lastPanY = t.clientY;
                    } else {
                        const ddx = t.clientX - lastPanX;
                        const ddy = t.clientY - lastPanY;
                        config.originX += ddx;
                        config.originY += ddy;
                        lastPanX = t.clientX;
                        lastPanY = t.clientY;
                        draw();
                    }
                    hasMovedSignificantly = true;
                }
            }
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length < 2) {
                isPinchZooming = false;
            }
            if (e.touches.length === 0 && !hasMovedSignificantly && !touchWentToMultiFinger && !isPinchZooming) {
                const rect = canvas.getBoundingClientRect();
                const px = touchStartX - rect.left;
                const py = touchStartY - rect.top;
                handleCanvasClick(px, py);
            }
            if (e.touches.length === 0) {
                isSingleFingerPanning = false;
            }
        }, { passive: false });
        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            isPinchZooming = false;
            isSingleFingerPanning = false;
        }, { passive: false });
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                touchWentToMultiFinger = true;
            }
        }, { passive: false });

        function getPinchDistance(touches) {
            const x1 = touches[0].clientX;
            const y1 = touches[0].clientY;
            const x2 = touches[1].clientX;
            const y2 = touches[1].clientY;
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx*dx + dy*dy);
        }
        function getTouchCenter(touches) {
            const x1 = touches[0].clientX;
            const y1 = touches[0].clientY;
            const x2 = touches[1].clientX;
            const y2 = touches[1].clientY;
            return {
                x: (x1 + x2)/2,
                y: (y1 + y2)/2
            };
        }
        function pinchZoom(ratio, centerTouch) {
            const rect = canvas.getBoundingClientRect();
            const centerX = centerTouch.x - rect.left;
            const centerY = centerTouch.y - rect.top;
            const modelBefore = screenToModel(centerX, centerY);

            config.scaleFactor *= ratio;
            config.scaleFactor = Math.max(5, Math.min(500, config.scaleFactor));

            const screenAfter = modelToScreen(modelBefore.x, modelBefore.y);
            config.originX += (centerX - screenAfter.x);
            config.originY += (centerY - screenAfter.y);

            draw();
        }

        // Called if user did a "click" (desktop) or single-tap (mobile)
        function handleCanvasClick(px, py) {
            let mc = screenToModel(px, py);
            if (config.isSnap) {
                mc.x = snapInModelSpace(mc.x);
                mc.y = snapInModelSpace(mc.y);
            }
            if (config.mode === "node") {
                pushHistory();
                const newNodeId = "N" + (++model.nodeCounter);
                model.nodes[newNodeId] = { x: mc.x, y: mc.y };
            }
            else if (config.mode === "member") {
                const closest = findClosestNode(mc.x, mc.y);
                if (!closest) return;
                if (!tempSelectedNode) {
                    tempSelectedNode = closest;
                } else {
                    if (closest !== tempSelectedNode) {
                        let duplicate = false;
                        for (const mid in model.members) {
                            const m = model.members[mid];
                            if (
                                (m.startNode === tempSelectedNode && m.endNode === closest) ||
                                (m.startNode === closest && m.endNode === tempSelectedNode)
                            ) {
                                duplicate = true;
                                break;
                            }
                        }
                        if (!duplicate) {
                            pushHistory();
                            const memId = "M" + (++model.memberCounter);
                            model.members[memId] = {
                                startNode: tempSelectedNode,
                                endNode: closest,
                                type: config.memberType
                            };
                            updateMaxMemberLength();
                        } else {
                            console.log("Member with same start/end already exists.");
                        }
                    }
                    tempSelectedNode = null;
                }
            }
            else if (config.mode === "support") {
                const closest = findClosestNode(mc.x, mc.y);
                if (!closest) return;
                pushHistory();
                model.supports[closest] = { type: config.supportType };
            }
            else if (config.mode === "load") {
                if (config.loadType === "point") {
                    const closest = findClosestNode(mc.x, mc.y);
                    if (!closest) return;
                    pushHistory();
                    const lid = "L" + (++model.loadCounter);
                    if (config.loadDir === "x") {
                        model.loads[lid] = {
                            type: "point",
                            node: closest,
                            values: [config.loadValue, 0]
                        };
                    } else {
                        model.loads[lid] = {
                            type: "point",
                            node: closest,
                            values: [0, config.loadValue]
                        };
                    }
                }
                else if (config.loadType === "uniform" || config.loadType === "nonuniform") {
                    const mid = findClosestMember(mc.x, mc.y);
                    if (!mid) return;
                    if (model.members[mid].type === "truss") {
                        console.log("Cannot assign distributed load on truss.");
                        return;
                    }
                    pushHistory();
                    const lid = "L" + (++model.loadCounter);
                    if (config.loadType === "uniform") {
                        if (config.loadDir === "x") {
                            model.loads[lid] = {
                                type: "uniform",
                                member: mid,
                                values: [config.loadValue, 0]
                            };
                        } else {
                            model.loads[lid] = {
                                type: "uniform",
                                member: mid,
                                values: [0, config.loadValue]
                            };
                        }
                    } else {
                        // nonuniform
                        model.loads[lid] = {
                            type: "nonuniform",
                            member: mid,
                            start_val: config.nuStartVal,
                            end_val: config.nuEndVal,
                            dir: config.loadDir
                        };
                    }
                }
            }
            updateModelStats();
            draw();
        }

        // Basic coordinate transformations
        function screenToModel(sx, sy) {
            const mx = (sx - config.originX) / config.scaleFactor;
            const my = (config.originY - sy) / config.scaleFactor; // invert y
            return { x: mx, y: my };
        }
        function modelToScreen(mx, my) {
            const sx = config.originX + (mx * config.scaleFactor);
            const sy = config.originY - (my * config.scaleFactor);
            return { x: sx, y: sy };
        }
        function snapInModelSpace(coord) {
            return Math.round(coord / config.gridSpacing) * config.gridSpacing;
        }

        // find closest node
        function findClosestNode(mX, mY, tol = 10) {
            let closestId = null;
            let minDist = Infinity;
            for (const nid in model.nodes) {
                const nd = model.nodes[nid];
                const s1 = modelToScreen(nd.x, nd.y);
                const s2 = modelToScreen(mX, mY);
                const d = Math.hypot(s1.x - s2.x, s1.y - s2.y);
                if (d < minDist) {
                    minDist = d;
                    closestId = nid;
                }
            }
            return (minDist <= tol) ? closestId : null;
        }
        // find closest member
        function findClosestMember(mX, mY, tol = 10) {
            let closestId = null;
            let minDist = Infinity;
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = model.nodes[mem.startNode];
                const en = model.nodes[mem.endNode];
                if (!sn || !en) continue;
                const sPt = modelToScreen(mX, mY);
                const sA = modelToScreen(sn.x, sn.y);
                const sB = modelToScreen(en.x, en.y);
                const dist = pointToSegmentDist(sPt.x, sPt.y, sA.x, sA.y, sB.x, sB.y);
                if (dist < minDist) {
                    minDist = dist;
                    closestId = mid;
                }
            }
            return (minDist <= tol) ? closestId : null;
        }
        function pointToSegmentDist(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len2 = dx*dx + dy*dy;
            if (len2 === 0) {
                return Math.hypot(px - x1, py - y1);
            }
            let t = ((px - x1)*dx + (py - y1)*dy) / len2;
            t = Math.max(0, Math.min(1, t));
            const cx = x1 + t * dx;
            const cy = y1 + t * dy;
            return Math.hypot(px - cx, py - cy);
        }

        // Undo / Clear / Save
        function pushHistory() {
            const snapshot = JSON.parse(JSON.stringify(model));
            history.push(snapshot);
            if (history.length > maxHistory) history.shift();
        }
        function popHistory() {
            if (!history.length) {
                console.log("Nothing to undo.");
                return;
            }
            const last = history.pop();
            Object.assign(model, last);
            tempSelectedNode = null;
            updateMaxMemberLength();
            updateModelStats();
            draw();
        }
        function handleUndo() {
            popHistory();
        }
        function handleClear() {
            pushHistory();
            model.nodes = {};
            model.members = {};
            model.supports = {};
            model.loads = {};
            model.nodeCounter = 0;
            model.memberCounter = 0;
            model.loadCounter = 0;
            tempSelectedNode = null;
            maxMemberLength = 0;
            updateModelStats();
            draw();
        }
        function handleSave() {
            const exportData = {
                nodes: model.nodes,
                members: model.members,
                supports: model.supports,
                loads: model.loads
            };
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "structural_model.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateModelStats() {
            modelStats.innerHTML = `
                Nodes: ${Object.keys(model.nodes).length}<br>
                Members: ${Object.keys(model.members).length}<br>
                Supports: ${Object.keys(model.supports).length}<br>
                Loads: ${Object.keys(model.loads).length}
            `;
        }
        function updateMaxMemberLength() {
            maxMemberLength = 0;
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = model.nodes[mem.startNode];
                const en = model.nodes[mem.endNode];
                if (!sn || !en) continue;
                const dx = en.x - sn.x;
                const dy = en.y - sn.y;
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len > maxMemberLength) maxMemberLength = len;
            }
        }

        // Main drawing
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (config.isSnap) {
                drawGrid();
            }
            drawMembers();
            drawNodes();
            drawSupports();
            drawLoads();

            if (tempSelectedNode && config.mode === "member") {
                // highlight selected node
                const nd = model.nodes[tempSelectedNode];
                if (nd) {
                    const s = modelToScreen(nd.x, nd.y);
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = "orange";
                    ctx.lineWidth = 2;
                    ctx.arc(s.x, s.y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            drawCursorCoordinates();
        }

        function drawCursorCoordinates() {
            const mc = screenToModel(cursorX, cursorY);
            const text = `(${mc.x.toFixed(2)}m, ${mc.y.toFixed(2)}m)`;
            const pad = 10;
            const tw = ctx.measureText(text).width;
            const boxH = 20;

            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(canvas.width - tw - pad*2, canvas.height - boxH - pad, tw + pad*2, boxH);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width - tw/2 - pad, canvas.height - pad - 5);
            ctx.textAlign = "left";
        }

        // Draw grid with minor lines at config.gridSpacing, major at 5m
        function drawGrid() {
            ctx.save();
            const topLeft = screenToModel(0, 0);
            const bottomRight = screenToModel(canvas.width, canvas.height);

            // minor lines
            const xStart = Math.floor(topLeft.x / config.gridSpacing) * config.gridSpacing;
            const xEnd   = Math.ceil(bottomRight.x / config.gridSpacing) * config.gridSpacing;
            const yStart = Math.floor(bottomRight.y / config.gridSpacing) * config.gridSpacing;
            const yEnd   = Math.ceil(topLeft.y / config.gridSpacing) * config.gridSpacing;

            ctx.strokeStyle = "#e0e0e0";
            ctx.lineWidth = 0.5;

            // vertical minor
            for (let x = xStart; x <= xEnd; x += config.gridSpacing) {
                const sx = modelToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(sx, 0);
                ctx.lineTo(sx, canvas.height);
                ctx.stroke();
            }
            // horizontal minor
            for (let y = yStart; y <= yEnd; y += config.gridSpacing) {
                const sy = modelToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, sy);
                ctx.lineTo(canvas.width, sy);
                ctx.stroke();
            }

            // major lines at 5m
            const majorSpacing = 5;
            ctx.strokeStyle = "#d0d0d0";
            ctx.lineWidth = 0.8;

            const xStartMaj = Math.floor(topLeft.x / majorSpacing) * majorSpacing;
            const xEndMaj   = Math.ceil(bottomRight.x / majorSpacing) * majorSpacing;
            for (let x = xStartMaj; x <= xEndMaj; x += majorSpacing) {
                const sx = modelToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(sx, 0);
                ctx.lineTo(sx, canvas.height);
                ctx.stroke();
            }

            const yStartMaj = Math.floor(bottomRight.y / majorSpacing) * majorSpacing;
            const yEndMaj   = Math.ceil(topLeft.y / majorSpacing) * majorSpacing;
            for (let y = yStartMaj; y <= yEndMaj; y += majorSpacing) {
                const sy = modelToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, sy);
                ctx.lineTo(canvas.width, sy);
                ctx.stroke();
            }

            // axes
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 1.5;
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, config.originY);
            ctx.lineTo(canvas.width, config.originY);
            ctx.stroke();

            // Y-axis
            ctx.beginPath();
            ctx.moveTo(config.originX, 0);
            ctx.lineTo(config.originX, canvas.height);
            ctx.stroke();

            // axis labels
            ctx.font = "bold 14px Arial";
            ctx.fillStyle = "#333";
            ctx.textAlign = "center";
            ctx.fillText("X (m)", canvas.width / 2, config.originY + 40);

            ctx.save();
            ctx.translate(config.originX - 40, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("Y (m)", 0, 0);
            ctx.restore();

            // minor numeric labels (skip if multiple of 5)
            ctx.font = "12px Arial";
            ctx.fillStyle = "#777";

            for (let x = xStart; x <= xEnd; x += config.gridSpacing) {
                if (Math.abs(x) < 0.001) continue;
                if (Math.abs(x % 5) < 0.001) continue; // skip if multiple of 5
                const sx = modelToScreen(x, 0).x;
                ctx.textAlign = "center";
                ctx.fillText(`${x.toFixed(1)}`, sx, config.originY + 15);
            }
            for (let y = yStart; y <= yEnd; y += config.gridSpacing) {
                if (Math.abs(y) < 0.001) continue;
                if (Math.abs(y % 5) < 0.001) continue; // skip if multiple of 5
                const sy = modelToScreen(0, y).y;
                ctx.textAlign = "right";
                ctx.fillText(`${y.toFixed(1)}`, config.originX - 5, sy + 3);
            }

            // major numeric labels
            ctx.fillStyle = "#222";
            // X
            for (let x = xStartMaj; x <= xEndMaj; x += majorSpacing) {
                if (Math.abs(x) < 0.001) continue;
                const sx = modelToScreen(x, 0).x;
                ctx.textAlign = "center";
                ctx.fillText(`${x.toFixed(0)}m`, sx, config.originY + 20);
            }
            // Y
            for (let y = yStartMaj; y <= yEndMaj; y += majorSpacing) {
                if (Math.abs(y) < 0.001) continue;
                const sy = modelToScreen(0, y).y;
                ctx.textAlign = "right";
                ctx.fillText(`${y.toFixed(0)}m`, config.originX - 10, sy + 4);
            }

            // origin label
            ctx.fillStyle = "#000";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.fillText("(0,0)", config.originX + 5, config.originY - 5);

            // top-left grid info
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(10, 10, 160, 30);
            ctx.fillStyle = "white";
            ctx.font = "14px Arial";
            ctx.fillText(`Grid Spacing: ${config.gridSpacing}m`, 20, 30);

            ctx.restore();
        }

        function drawNodes() {
            for (const nid in model.nodes) {
                const nd = model.nodes[nid];
                const sc = modelToScreen(nd.x, nd.y);
                ctx.beginPath();
                ctx.fillStyle = "#1a75ff";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;
                ctx.arc(sc.x, sc.y, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();

                // label
                ctx.font = "14px Arial";
                ctx.fillStyle = "black";
                ctx.fillText(nid, sc.x+8, sc.y+8);
            }
        }

        function drawMembers() {
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = model.nodes[mem.startNode];
                const en = model.nodes[mem.endNode];
                if (!sn || !en) continue;
                const start = modelToScreen(sn.x, sn.y);
                const end   = modelToScreen(en.x, en.y);

                const color = (mem.type === "beam") ? "#006633" : "blue";
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();

                // label at midpoint
                const mx = (start.x + end.x)/2;
                const my = (start.y + end.y)/2;
                const txt = mid;
                const w = ctx.measureText(txt).width;
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.fillRect(mx - w/2 - 2, my - 8, w+4, 16);
                ctx.fillStyle = "#000";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText(mid, mx, my+2);
                ctx.textAlign = "left";
            }
        }

        function drawSupports() {
            const s = (maxMemberLength>0) ? Math.max(0.5, maxMemberLength/9) : 10;
            const supportPix = s * config.scaleFactor;
            for (const node_id in model.supports) {
                const sup = model.supports[node_id];
                const nd = model.nodes[node_id];
                if (!nd) continue;
                const sc = modelToScreen(nd.x, nd.y);
                ctx.save();
                ctx.translate(sc.x, sc.y);
                ctx.fillStyle = "purple";
                switch (sup.type) {
                    case "fixed":
                        ctx.save();
                        ctx.fillStyle = "#888";
                        ctx.fillRect(-supportPix/2, -supportPix/2, supportPix, supportPix);
                        // hatching
                        ctx.strokeStyle = "#444";
                        ctx.lineWidth = 1;
                        const hatchSpacing = supportPix/8;
                        for (let i = 0; i <= supportPix; i += hatchSpacing) {
                            ctx.beginPath();
                            ctx.moveTo(-supportPix/2, -supportPix/2 + i);
                            ctx.lineTo(supportPix/2, -supportPix/2 + i);
                            ctx.stroke();

                            ctx.beginPath();
                            ctx.moveTo(-supportPix/2 + i, -supportPix/2);
                            ctx.lineTo(-supportPix/2 + i, supportPix/2);
                            ctx.stroke();
                        }
                        ctx.restore();
                        break;
                    case "roller_x":
                        // left pointing triangle
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix, -supportPix/2);
                        ctx.lineTo(-supportPix, supportPix/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case "roller_y":
                        // up pointing triangle
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix/2, supportPix);
                        ctx.lineTo(supportPix/2, supportPix);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case "hinge":
                        // combo roller_x + roller_y
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix, -supportPix/2);
                        ctx.lineTo(-supportPix, supportPix/2);
                        ctx.closePath();
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix/2, supportPix);
                        ctx.lineTo(supportPix/2, supportPix);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        function drawLoads() {
            const distributedPositions = [0, 1/6, 2/6, 3/6, 4/6, 5/6, 1];
            const arrowLenPointUniform = maxMemberLength * (1/5);
            const arrowLenMinNonuniform = maxMemberLength * (1/7);
            const arrowLenMaxNonuniform = maxMemberLength * (1/5);

            for (const lid in model.loads) {
                const ld = model.loads[lid];
                if (ld.type === "point") {
                    const nd = (ld.node) ? model.nodes[ld.node] : null;
                    if (!nd) continue;
                    const sc = modelToScreen(nd.x, nd.y);
                    const fx = (ld.values) ? ld.values[0] : 0;
                    const fy = (ld.values) ? ld.values[1] : 0;
                    
                    const arrLenM = arrowLenPointUniform;
                    const arrLenPx = arrLenM * config.scaleFactor;

                    let dx = 0, dy = 0;
                    if (Math.abs(fx) > 1e-6) {
                        dx = (fx < 0) ? -arrLenPx : arrLenPx;
                    }
                    if (Math.abs(fy) > 1e-6) {
                        dy = (fy < 0) ? arrLenPx : -arrLenPx;
                    }
                    drawArrow(sc.x - dx, sc.y - dy, sc.x, sc.y, "red");

                    // --- X-label positioning fix ---
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "red";

                    // Build the label string
                    let label = "";
                    if (Math.abs(fx) > 1e-6 && Math.abs(fy) > 1e-6) {
                        // both x & y => old logic
                        label = `${Math.abs(fx)}N, ${Math.abs(fy)}N`;
                        // keep old positioning
                        ctx.fillText(label, sc.x - dx, sc.y - dy);
                    }
                    else if (Math.abs(fx) > 1e-6) {
                        // purely X direction
                        label = `${Math.abs(fx)}N`;
                        if (fx > 0) {
                            // positive X => place text to the left of the tail
                            ctx.textAlign = "right";
                            ctx.fillText(label, (sc.x - dx) - 4, sc.y - dy);
                        } else {
                            // negative X => place text to the right of the tail
                            ctx.textAlign = "left";
                            ctx.fillText(label, (sc.x - dx) + 4, sc.y - dy);
                        }
                        ctx.textAlign = "left"; // restore default
                    }
                    else if (Math.abs(fy) > 1e-6) {
                        // purely Y direction => unchanged
                        label = `${Math.abs(fy)}N`;
                        ctx.fillText(label, sc.x - dx, sc.y - dy);
                    }
                }
                else if (ld.type === "uniform") {
                    const mem = (ld.member) ? model.members[ld.member] : null;
                    if (!mem || mem.type === "truss") continue;
                    const sn = model.nodes[mem.startNode];
                    const en = model.nodes[mem.endNode];
                    if (!sn || !en) continue;
                    const dxm = en.x - sn.x;
                    const dym = en.y - sn.y;
                    const arrLenPx = arrowLenPointUniform * config.scaleFactor;
                    const fx = ld.values[0];
                    const fy = ld.values[1];

                    // 7 arrows along the member
                    for (let i = 0; i < distributedPositions.length; i++) {
                        const t = distributedPositions[i];
                        const xM = sn.x + t*dxm;
                        const yM = sn.y + t*dym;
                        const sc = modelToScreen(xM, yM);

                        let ax = 0, ay = 0;
                        if (Math.abs(fx) > 1e-6) {
                            ax = (fx < 0) ? -arrLenPx : arrLenPx;
                        }
                        if (Math.abs(fy) > 1e-6) {
                            ay = (fy < 0) ? arrLenPx : -arrLenPx;
                        }
                        drawArrow(sc.x - ax, sc.y - ay, sc.x, sc.y, "red");
                    }
                    // label near midpoint
                    const midX = sn.x + 0.5*dxm;
                    const midY = sn.y - 0.5*dym;
                    const midS = modelToScreen(midX, midY);
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "red";
                    let label = "";
                    if (Math.abs(fx) > 1e-6 && Math.abs(fy) > 1e-6) {
                        label = `${Math.abs(fx)}N/m, ${Math.abs(fy)}N/m`;
                    } else if (Math.abs(fx) > 1e-6) {
                        label = `${Math.abs(fx)}N/m`;
                    } else if (Math.abs(fy) > 1e-6) {
                        label = `${Math.abs(fy)}N/m`;
                    }
                    ctx.fillText(label, midS.x, midS.y + arrLenPx*Math.sign(fy));
                }
                else if (ld.type === "nonuniform") {
                    const mem = (ld.member) ? model.members[ld.member] : null;
                    if (!mem || mem.type === "truss") continue;
                    const sn = model.nodes[mem.startNode];
                    const en = model.nodes[mem.endNode];
                    if (!sn || !en) continue;
                    const dxm = en.x - sn.x;
                    const dym = en.y - sn.y;

                    const minPx = arrowLenMinNonuniform * config.scaleFactor;
                    const maxPx = arrowLenMaxNonuniform * config.scaleFactor;

                    const dir = ld.dir || "y";
                    const startVal = ld.start_val ?? -1000;
                    const endVal   = ld.end_val   ?? -500;

                    // 7 arrows
                    for (let i = 0; i < distributedPositions.length; i++) {
                        const t = distributedPositions[i];
                        const valT = startVal + t*(endVal - startVal);
                        const absValT = Math.abs(valT);

                        const absStart = Math.abs(startVal);
                        const absEnd   = Math.abs(endVal);
                        const dataMin = Math.min(absStart, absEnd);
                        const dataMax = Math.max(absStart, absEnd);
                        const range = Math.max(dataMax - dataMin, 1e-6);
                        const fraction = (absValT - dataMin)/range;
                        let arrowPx = minPx + fraction*(maxPx - minPx);

                        const xM = sn.x + t*dxm;
                        const yM = sn.y + t*dym;
                        const sc = modelToScreen(xM, yM);

                        let ax = 0, ay = 0;
                        if (dir === "x") {
                            ax = (valT < 0)? -arrowPx : arrowPx;
                        } else {
                            ay = (valT < 0)? arrowPx : -arrowPx;
                        }
                        drawArrow(sc.x - ax, sc.y - ay, sc.x, sc.y, "red");
                    }
                    // label near midpoint
                    const midX = sn.x + 0.5*dxm;
                    const midY = sn.y + 0.5*dym;
                    const midS = modelToScreen(midX, midY);
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "red";
                    ctx.fillText(`[${Math.abs(startVal)} -> ${Math.abs(endVal)}] N/m`,
                                 midS.x, 
                                 midS.y + maxPx*Math.sign(startVal));
                }
            }
        }

        function drawArrow(fromX, fromY, toX, toY, color) {
            const headLength = 8;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI/6),
                toY - headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI/6),
                toY - headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
        }

        // initial
        draw();
        updateModelStats();
    </script>
</body>
</html>
