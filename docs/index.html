<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structural FEM Tool</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 300px;
            background: #e6e6e6;
            padding: 10px;
            overflow-y: auto;
        }
        .canvas-container {
            flex: 1;
            background: #fff;
            position: relative;
        }
        canvas {
            border: 1px solid #ccc;
        }
        h2 {
            margin-top: 0;
        }
        .section {
            margin-top: 10px;
        }
        button {
            margin-right: 5px;
            margin-top: 5px;
        }
        input[type="number"] {
            width: 80px;
        }
        .faded {
            opacity: 0.3;
        }
        .summary {
            margin-top: 10px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }
        
    </style>
</head>
<body>
    <div class="container">
        <!-- Left panel -->
        <div class="sidebar">
            <h2>Structural FEM Tool</h2>
            <p><em>By Mohammad Talebi-Kalaleh (talebika@ualberta.ca)</em></p>
            
            <!-- Mode selection -->
            <div class="section">
                <strong>Mode</strong>
                <div>
                    <label><input type="radio" name="mode" value="node" checked> Node</label><br>
                    <label><input type="radio" name="mode" value="member"> Member</label><br>
                    <label><input type="radio" name="mode" value="support"> Support</label><br>
                    <label><input type="radio" name="mode" value="load"> Load</label><br>
                </div>
            </div>
            
            <!-- Member Type -->
            <div class="section member-options">
                <strong>Member Type</strong>
                <div>
                    <label><input type="radio" name="memType" value="beam" checked> Beam</label><br>
                    <label><input type="radio" name="memType" value="truss"> Truss</label><br>
                </div>
            </div>
            
            <!-- Support Type -->
            <div class="section support-options">
                <strong>Support Type</strong>
                <div>
                    <label><input type="radio" name="supportType" value="fixed" checked> Fixed</label><br>
                    <label><input type="radio" name="supportType" value="roller_x"> Roller-X</label><br>
                    <label><input type="radio" name="supportType" value="roller_y"> Roller-Y</label><br>
                    <label><input type="radio" name="supportType" value="hinge"> Hinge</label><br>
                </div>
            </div>
            
            <!-- Load Settings -->
            <div class="section load-options">
                <strong>Load Settings</strong>
                <div>
                    <div>
                        <label><input type="radio" name="loadType" value="point" checked> Point</label><br>
                        <label><input type="radio" name="loadType" value="uniform"> Uniform</label><br>
                        <label><input type="radio" name="loadType" value="nonuniform"> Nonuniform</label><br>
                    </div>
                    <div>
                        <label><input type="radio" name="loadDir" value="x"> X</label><br>
                        <label><input type="radio" name="loadDir" value="y" checked> Y</label><br>
                    </div>
                    
                    <!-- Load Value -->
                    <div id="uniform-load-value">
                        <label>Load Value (N or N/m):</label><br>
                        <input type="number" id="loadValue" value="-1000"><br>
                    </div>
                    
                    <!-- Nonuniform Load Values -->
                    <div id="nonuniform-load-values" style="display: none;">
                        <label>Start Value:</label><br>
                        <input type="number" id="nuStartVal" value="-1000"><br>
                        <label>End Value:</label><br>
                        <input type="number" id="nuEndVal" value="-500"><br>
                    </div>
                </div>
            </div>
            
            <!-- Grid Settings -->
            <div class="section">
                <strong>Grid Settings</strong><br>
                <label><input type="checkbox" id="isSnap" checked> Grid Snap</label><br>
                <label>Grid spacing (meters):</label><br>
                <select id="gridSpacingSelect">
                    <option value="0.1">0.1 m</option>
                    <option value="0.5">0.5 m</option>
                    <option value="1" selected>1 m</option>
                    <option value="2">2 m</option>
                    <option value="5">5 m</option>
                </select>
            </div>
            
            <!-- Buttons -->
            <div class="section">
                <button id="undoBtn">Undo</button>
                <button id="clearBtn">Clear All</button>
                <button id="saveBtn">Save Model</button>
            </div>
            
            <!-- Summary -->
            <div class="summary">
                <strong>Model Summary</strong>
                <div id="model-stats">
                    Nodes: 0<br>
                    Members: 0<br>
                    Supports: 0<br>
                    Loads: 0
                </div>
            </div>
        </div>
        
        <!-- Canvas area -->
        <div class="canvas-container">
            <canvas id="femCanvas"></canvas>
        </div>
    </div>

    <script>
        // Main model data
        const model = {
            // All coordinates below should be in *meters*.
            nodes: {},           // { nodeId: { x, y } }
            members: {},         // { memId: { startNode, endNode, type: beam/truss } }
            supports: {},        // { nodeId: { type: fixed/roller_x/roller_y/hinge } }
            loads: {},           // { loadId: { ... load data ... } }
            nodeCounter: 0,
            memberCounter: 0,
            loadCounter: 0
        };

        // Configuration
        const config = {
            mode: "node",         // node | member | support | load
            memberType: "beam",   // beam | truss
            supportType: "fixed", // fixed, roller_x, roller_y, hinge
            loadType: "point",    // point, uniform, nonuniform
            loadDir: "y",         // x | y
            loadValue: -1000,     // for point/uniform
            nuStartVal: -1000,    // for nonuniform start
            nuEndVal: -500,       // for nonuniform end
            isSnap: true,
            gridSpacing: 1,       // in meters
            scaleFactor: 30,      // pixels per meter
            originX: 0,           // X coordinate of origin in screen
            originY: 0            // Y coordinate of origin in screen
        };

        // Temporary selected node for member creation
        let tempSelectedNode = null;

        // Store the max member length (in meters) to scale arrow/support sizes
        let maxMemberLength = 0;

        // History stack for undo
        const history = [];
        const maxHistory = 50;

        // Canvas and context
        const canvas = document.getElementById('femCanvas');
        const ctx = canvas.getContext('2d');
        
        // For cursor coordinates (in screen space)
        let cursorX = 0;
        let cursorY = 0;

        // Set canvas size and origin
        function resizeCanvas() {
            canvas.width = window.innerWidth - 320;
            canvas.height = window.innerHeight;
            
            // Set origin at bottom-left with some padding
            config.originX = 50;
            config.originY = canvas.height - 50;
            
            // Optionally snap origin to the grid in screen coordinates
            config.originX = Math.round(config.originX / config.scaleFactor) * config.scaleFactor;
            config.originY = Math.round(config.originY / config.scaleFactor) * config.scaleFactor;
            
            draw();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // UI references
        const modeRadios = document.querySelectorAll('input[name="mode"]');
        const memberTypeRadios = document.querySelectorAll('input[name="memType"]');
        const supportTypeRadios = document.querySelectorAll('input[name="supportType"]');
        const loadTypeRadios = document.querySelectorAll('input[name="loadType"]');
        const loadDirRadios = document.querySelectorAll('input[name="loadDir"]');
        const loadValueInput = document.getElementById('loadValue');
        const nuStartValInput = document.getElementById('nuStartVal');
        const nuEndValInput = document.getElementById('nuEndVal');
        const uniformLoadValueDiv = document.getElementById('uniform-load-value');
        const nonuniformLoadValuesDiv = document.getElementById('nonuniform-load-values');
        const isSnapCheckbox = document.getElementById('isSnap');
        const gridSpacingSelect = document.getElementById('gridSpacingSelect');
        const undoBtn = document.getElementById('undoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const modelStats = document.getElementById('model-stats');

        function updateOptionsVisibility() {
            // fade out / enable sections based on mode
            document.querySelector('.member-options > div').classList.toggle('faded', config.mode !== 'member');
            document.querySelector('.support-options > div').classList.toggle('faded', config.mode !== 'support');
            document.querySelector('.load-options > div').classList.toggle('faded', config.mode !== 'load');
            
            // enable/disable inputs
            document.querySelectorAll('.member-options input').forEach(input => {
                input.disabled = (config.mode !== 'member');
            });
            document.querySelectorAll('.support-options input').forEach(input => {
                input.disabled = (config.mode !== 'support');
            });
            document.querySelectorAll('.load-options input').forEach(input => {
                input.disabled = (config.mode !== 'load');
            });
            
            // Show/hide nonuniform fields
            if (config.loadType === 'nonuniform') {
                uniformLoadValueDiv.style.display = 'none';
                nonuniformLoadValuesDiv.style.display = 'block';
            } else {
                uniformLoadValueDiv.style.display = 'block';
                nonuniformLoadValuesDiv.style.display = 'none';
            }
        }

        function updateMaxMemberLength() {
            // Recompute maxMemberLength based on all existing members (in meters).
            maxMemberLength = 0;
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = model.nodes[mem.startNode];
                const en = model.nodes[mem.endNode];
                if (!sn || !en) continue;
                const dx = en.x - sn.x;
                const dy = en.y - sn.y;
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len > maxMemberLength) maxMemberLength = len;
            }
        }

        // Event listeners
        modeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    config.mode = radio.value;
                    updateOptionsVisibility();
                }
            });
        });
        memberTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) config.memberType = radio.value;
            });
        });
        supportTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) config.supportType = radio.value;
            });
        });
        loadTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    config.loadType = radio.value;
                    updateOptionsVisibility();
                }
            });
        });
        loadDirRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) config.loadDir = radio.value;
            });
        });

        loadValueInput.addEventListener('change', () => {
            config.loadValue = parseFloat(loadValueInput.value) || -1000;
        });
        nuStartValInput.addEventListener('change', () => {
            config.nuStartVal = parseFloat(nuStartValInput.value) || -1000;
        });
        nuEndValInput.addEventListener('change', () => {
            config.nuEndVal = parseFloat(nuEndValInput.value) || -500;
        });

        isSnapCheckbox.addEventListener('change', () => {
            config.isSnap = isSnapCheckbox.checked;
            draw();
        });
        gridSpacingSelect.addEventListener('change', () => {
            const val = parseFloat(gridSpacingSelect.value);
            if (!isNaN(val) && val > 0) {
                config.gridSpacing = val;
                draw();
            }
        });

        undoBtn.addEventListener('click', handleUndo);
        clearBtn.addEventListener('click', handleClear);
        saveBtn.addEventListener('click', handleSave);

        // Canvas interactions
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const pixelX = e.clientX - rect.left;
            const pixelY = e.clientY - rect.top;
            
            handleCanvasClick(pixelX, pixelY);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            cursorX = e.clientX - rect.left;
            cursorY = e.clientY - rect.top;
            draw(); // to update the coordinate display
        });

        // Convert screen coords → model coords (meters)
        function screenToModel(sx, sy) {
            const mx = (sx - config.originX) / config.scaleFactor;
            const my = (config.originY - sy) / config.scaleFactor; // invert y
            return {x: mx, y: my};
        }

        // Convert model coords (meters) → screen coords
        function modelToScreen(mx, my) {
            const sx = config.originX + mx * config.scaleFactor;
            const sy = config.originY - my * config.scaleFactor;
            return {x: sx, y: sy};
        }

        // Snap a model coordinate to the nearest grid step
        function snapInModelSpace(coord) {
            return Math.round(coord / config.gridSpacing) * config.gridSpacing;
        }

        // Returns the ID of the closest node (in model space) within 'tolerance' (in screen px)
        function findClosestNode(mX, mY, tolerancePx=10) {
            let closestId = null;
            let minDist = Infinity;
            for (const nid in model.nodes) {
                const nd = model.nodes[nid];
                const dx = nd.x - mX;
                const dy = nd.y - mY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                // Convert that distance to screen space to compare with tolerance
                const {x: s1, y: s2} = modelToScreen(nd.x, nd.y);
                const {x: s3, y: s4} = modelToScreen(mX, mY);
                const screenDist = Math.sqrt((s1 - s3)**2 + (s2 - s4)**2);
                if (screenDist < minDist) {
                    minDist = screenDist;
                    closestId = nid;
                }
            }
            if (minDist <= tolerancePx) return closestId;
            return null;
        }

        // Returns the ID of the closest member within 'tolerance' in screen px
        function findClosestMember(mX, mY, tolerancePx=10) {
            let closestId = null;
            let minDist = Infinity;
            // For each member, measure the distance from the point to the line segment
            for (const mid in model.members) {
                const mem = model.members[mid];
                const startN = model.nodes[mem.startNode];
                const endN = model.nodes[mem.endNode];
                if (!startN || !endN) continue;
                // First convert the test point and the endpoints to screen
                const sPt = modelToScreen(mX, mY);
                const sA = modelToScreen(startN.x, startN.y);
                const sB = modelToScreen(endN.x, endN.y);

                const distScreen = pointToSegmentDist(sPt.x, sPt.y, sA.x, sA.y, sB.x, sB.y);
                if (distScreen < minDist) {
                    minDist = distScreen;
                    closestId = mid;
                }
            }
            return (minDist <= tolerancePx) ? closestId : null;
        }

        // distance from point(px,py) to line segment (x1,y1)-(x2,y2)
        function pointToSegmentDist(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len2 = dx*dx + dy*dy;
            if (len2 === 0) {
                // segment is a point
                return Math.hypot(px - x1, py - y1);
            }
            let t = ((px - x1)*dx + (py - y1)*dy) / len2;
            t = Math.max(0, Math.min(1, t));
            const cx = x1 + t*dx;
            const cy = y1 + t*dy;
            return Math.hypot(px - cx, py - cy);
        }

        function handleCanvasClick(px, py) {
            // Convert screen to model
            let mc = screenToModel(px, py);
            if (config.isSnap) {
                mc.x = snapInModelSpace(mc.x);
                mc.y = snapInModelSpace(mc.y);
            }

            if (config.mode === "node") {
                // Create a new node in model space
                pushHistory();
                const newNodeId = "N" + (++model.nodeCounter);
                model.nodes[newNodeId] = { x: mc.x, y: mc.y };
            }
            else if (config.mode === "member") {
                const closest = findClosestNode(mc.x, mc.y);
                if (!closest) return;
                if (!tempSelectedNode) {
                    tempSelectedNode = closest;
                } else {
                    if (closest !== tempSelectedNode) {
                        // Check for duplicates
                        const startN = tempSelectedNode;
                        const endN = closest;
                        let duplicate = false;
                        for (const mid in model.members) {
                            const existing = model.members[mid];
                            const s = existing.startNode;
                            const e = existing.endNode;
                            if (
                                (s === startN && e === endN) ||
                                (s === endN && e === startN)
                            ) {
                                duplicate = true;
                                break;
                            }
                        }
                        if (!duplicate) {
                            pushHistory();
                            const memId = "M" + (++model.memberCounter);
                            model.members[memId] = {
                                startNode: startN,
                                endNode: endN,
                                type: config.memberType
                            };
                            updateMaxMemberLength();
                        } else {
                            console.log("Member with same start/end already exists.");
                        }
                    }
                    tempSelectedNode = null;
                }
            }
            else if (config.mode === "support") {
                const closest = findClosestNode(mc.x, mc.y);
                if (!closest) return;
                pushHistory();
                model.supports[closest] = { type: config.supportType };
            }
            else if (config.mode === "load") {
                if (config.loadType === "point") {
                    const closest = findClosestNode(mc.x, mc.y);
                    if (!closest) return;
                    pushHistory();
                    const lid = "L" + (++model.loadCounter);
                    if (config.loadDir === "x") {
                        model.loads[lid] = {
                            type: "point",
                            node: closest,
                            values: [config.loadValue, 0]
                        };
                    } else {
                        model.loads[lid] = {
                            type: "point",
                            node: closest,
                            values: [0, config.loadValue]
                        };
                    }
                }
                else if (config.loadType === "uniform" || config.loadType === "nonuniform") {
                    const mid = findClosestMember(mc.x, mc.y);
                    if (!mid) return;
                    // no distributed load on truss
                    if (model.members[mid].type === "truss") {
                        console.log("Cannot assign distributed load on truss.");
                        return;
                    }
                    pushHistory();
                    const lid = "L" + (++model.loadCounter);
                    
                    if (config.loadType === "uniform") {
                        if (config.loadDir === "x") {
                            model.loads[lid] = {
                                type: "uniform",
                                member: mid,
                                values: [config.loadValue, 0]
                            };
                        } else {
                            model.loads[lid] = {
                                type: "uniform",
                                member: mid,
                                values: [0, config.loadValue]
                            };
                        }
                    } else {
                        // nonuniform
                        model.loads[lid] = {
                            type: "nonuniform",
                            member: mid,
                            start_val: config.nuStartVal,
                            end_val: config.nuEndVal,
                            dir: config.loadDir
                        };
                    }
                }
            }

            updateModelStats();
            draw();
        }

        function handleUndo() {
            popHistory();
        }

        function handleClear() {
            pushHistory();
            model.nodes = {};
            model.members = {};
            model.supports = {};
            model.loads = {};
            model.nodeCounter = 0;
            model.memberCounter = 0;
            model.loadCounter = 0;
            tempSelectedNode = null;
            maxMemberLength = 0;
            updateModelStats();
            draw();
        }

        function handleSave() {
            // Output in meters, with the actual signed loads
            // Model is already in meters, so just export
            const exportData = {
                nodes: model.nodes,
                members: model.members,
                supports: model.supports,
                loads: model.loads
            };
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "structural_model.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        // History
        function pushHistory() {
            const snapshot = JSON.parse(JSON.stringify(model));
            history.push(snapshot);
            if (history.length > maxHistory) history.shift();
        }
        function popHistory() {
            if (history.length === 0) {
                console.log("Nothing to undo.");
                return;
            }
            const last = history.pop();
            Object.assign(model, last);
            tempSelectedNode = null;
            updateMaxMemberLength();
            updateModelStats();
            draw();
        }

        function updateModelStats() {
            modelStats.innerHTML = `
                Nodes: ${Object.keys(model.nodes).length}<br>
                Members: ${Object.keys(model.members).length}<br>
                Supports: ${Object.keys(model.supports).length}<br>
                Loads: ${Object.keys(model.loads).length}
            `;
        }

        // Drawing
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (config.isSnap) {
                drawGrid();
            }
            drawMembers();
            drawNodes();
            drawSupports();
            drawLoads();
            
            if (tempSelectedNode && config.mode === "member") {
                // highlight selected node
                const nd = model.nodes[tempSelectedNode];
                if (nd) {
                    const {x: sx, y: sy} = modelToScreen(nd.x, nd.y);
                    ctx.beginPath();
                    ctx.setLineDash([5,5]);
                    ctx.strokeStyle = "orange";
                    ctx.lineWidth = 2;
                    ctx.arc(sx, sy, 8, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            drawCursorCoordinates();
        }

        function drawCursorCoordinates() {
            // Show the model-space coordinates of the current mouse position
            const mc = screenToModel(cursorX, cursorY);
            
            ctx.font = "12px Arial";
            const text = `(${mc.x.toFixed(2)}m, ${mc.y.toFixed(2)}m)`;
            const pad = 10;
            const textWidth = ctx.measureText(text).width;
            const boxHeight = 20;

            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(canvas.width - textWidth - pad*2, canvas.height - boxHeight - pad, textWidth + pad*2, boxHeight);
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(text, canvas.width - textWidth/2 - pad, canvas.height - pad - 5);
            ctx.textAlign = "left";
        }

        function drawGrid() {
            ctx.save();
            
            // Visible area corners (in model coords)
            const topLeft = screenToModel(0, 0);
            const bottomRight = screenToModel(canvas.width, canvas.height);
            
            // Grid line ranges
            const xStart = Math.floor(topLeft.x / config.gridSpacing) * config.gridSpacing;
            const xEnd = Math.ceil(bottomRight.x / config.gridSpacing) * config.gridSpacing;
            const yStart = Math.floor(bottomRight.y / config.gridSpacing) * config.gridSpacing; 
            const yEnd = Math.ceil(topLeft.y / config.gridSpacing) * config.gridSpacing;
            
            ctx.strokeStyle = "#e0e0e0";
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = xStart; x <= xEnd; x += config.gridSpacing) {
                const screenX = modelToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = yStart; y <= yEnd; y += config.gridSpacing) {
                const screenY = modelToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
            
            // Major lines
            const majorSpacing = Math.max(5 * config.gridSpacing, 1);
            ctx.strokeStyle = "#d0d0d0";
            ctx.lineWidth = 0.8;
            
            // Major vertical
            for (let x = Math.floor(xStart / majorSpacing) * majorSpacing; x <= xEnd; x += majorSpacing) {
                const screenX = modelToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Major horizontal
            for (let y = Math.floor(yStart / majorSpacing) * majorSpacing; y <= yEnd; y += majorSpacing) {
                const screenY = modelToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 1.5;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, config.originY);
            ctx.lineTo(canvas.width, config.originY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(config.originX, 0);
            ctx.lineTo(config.originX, canvas.height);
            ctx.stroke();
            
            // Axis labels
            ctx.font = "bold 14px Arial";
            ctx.fillStyle = "#333";
            
            // X label
            ctx.textAlign = "center";
            ctx.fillText("X (m)", canvas.width / 2, config.originY + 40);
            
            // Y label (rotated)
            ctx.save();
            ctx.translate(config.originX - 40, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("Y (m)", 0, 0);
            ctx.restore();
            
            // Minor numeric labels
            ctx.font = "12px Arial";
            // X
            for (let x = xStart; x <= xEnd; x += config.gridSpacing) {
                if (Math.abs(x) < 0.001) continue;
                const screenX = modelToScreen(x, 0).x;
                if (Math.abs(x % majorSpacing) < 0.001) {
                    ctx.fillStyle = "#222";
                    ctx.textAlign = "center";
                    ctx.fillText(`${x.toFixed(0)}m`, screenX, config.originY + 20);
                } else if (config.gridSpacing >= 0.5) {
                    ctx.fillStyle = "#777";
                    ctx.fillText(`${x.toFixed(1)}`, screenX, config.originY + 15);
                }
            }
            // Y
            for (let y = yStart; y <= yEnd; y += config.gridSpacing) {
                if (Math.abs(y) < 0.001) continue;
                const screenY = modelToScreen(0, y).y;
                if (Math.abs(y % majorSpacing) < 0.001) {
                    ctx.fillStyle = "#222";
                    ctx.textAlign = "right";
                    ctx.fillText(`${y.toFixed(0)}m`, config.originX - 10, screenY + 4);
                } else if (config.gridSpacing >= 0.5) {
                    ctx.fillStyle = "#777";
                    ctx.fillText(`${y.toFixed(1)}`, config.originX - 5, screenY + 3);
                }
            }
            
            // Origin label
            ctx.fillStyle = "#000";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.fillText("(0,0)", config.originX + 5, config.originY - 5);
            
            // Grid spacing display top-left
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(10, 10, 160, 30);
            ctx.fillStyle = "white";
            ctx.font = "14px Arial";
            ctx.fillText(`Grid Spacing: ${config.gridSpacing}m`, 20, 30);
            
            ctx.restore();
        }

        function drawNodes() {
            for (const nid in model.nodes) {
                const nd = model.nodes[nid];
                const sc = modelToScreen(nd.x, nd.y);
                ctx.beginPath();
                ctx.fillStyle = "#1a75ff";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;
                ctx.arc(sc.x, sc.y, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();

                // label
                ctx.font = "14px Arial";
                ctx.fillStyle = "black";
                ctx.fillText(nid, sc.x+8, sc.y+8);
            }
        }

        function drawMembers() {
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = model.nodes[mem.startNode];
                const en = model.nodes[mem.endNode];
                if (!sn || !en) continue;
                const start = modelToScreen(sn.x, sn.y);
                const end = modelToScreen(en.x, en.y);

                const color = (mem.type === "beam") ? "#006633" : "blue";
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();

                // label at midpoint
                const mx = (start.x + end.x)/2;
                const my = (start.y + end.y)/2;
                const txt = mid;
                const w = ctx.measureText(txt).width;
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.fillRect(mx - w/2 - 2, my - 8, w+4, 16);
                ctx.fillStyle = "#000";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText(mid, mx, my+2);
                ctx.textAlign = "left";
            }
        }

        function drawSupports() {
            // support size = 1/8 of maxMemberLength
            const s = (maxMemberLength > 0) ? Math.max(0.5, maxMemberLength/9) : 10; 
            // s is in meters, convert to screen
            const supportPix = s * config.scaleFactor;

            for (const node_id in model.supports) {
                const sup = model.supports[node_id];
                const nd = model.nodes[node_id];
                if (!nd) continue;
                const sc = modelToScreen(nd.x, nd.y);
                ctx.save();
                ctx.translate(sc.x, sc.y);
                ctx.fillStyle = "purple";
                switch(sup.type) {
                    case "fixed":
                        // draw a small square with hatching
                        ctx.save();
                        ctx.fillStyle = "#888";
                        ctx.fillRect(-supportPix/2, -supportPix/2, supportPix, supportPix);
                        // hatching
                        ctx.strokeStyle = "#444";
                        ctx.lineWidth = 1;
                        const hatchSpacing = supportPix/8;
                        for (let i = 0; i <= supportPix; i += hatchSpacing) {
                            // horizontal line
                            ctx.beginPath();
                            ctx.moveTo(-supportPix/2, -supportPix/2 + i);
                            ctx.lineTo(supportPix/2, -supportPix/2 + i);
                            ctx.stroke();
                            // vertical line
                            ctx.beginPath();
                            ctx.moveTo(-supportPix/2 + i, -supportPix/2);
                            ctx.lineTo(-supportPix/2 + i, supportPix/2);
                            ctx.stroke();
                        }
                        ctx.restore();
                        break;
                    case "roller_x":
                        // left pointing triangle
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix, -supportPix/2);
                        ctx.lineTo(-supportPix, supportPix/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case "roller_y":
                        // up pointing triangle
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix/2, supportPix);
                        ctx.lineTo(supportPix/2, supportPix);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case "hinge":
                        // combine roller_x + roller_y
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix, -supportPix/2);
                        ctx.lineTo(-supportPix, supportPix/2);
                        ctx.closePath();
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-supportPix/2, supportPix);
                        ctx.lineTo(supportPix/2, supportPix);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        function drawLoads() {
            // For distributed loads, we will place 7 arrows at t=0, 1/6, 2/6, 3/6, 4/6, 5/6, 1
            const distributedPositions = [0, 1/6, 2/6, 3/6, 4/6, 5/6, 1];

            // Arrow size rules:
            // 1. point & uniform => arrowLen = (1/5 of maxMemberLength in meters)
            // 2. nonuniform => arrowLen in [1/7, 1/5] of maxMemberLength, scaled by magnitude
            const arrowLenPointUniform = maxMemberLength * (1/5);
            const arrowLenMinNonuniform = maxMemberLength * (1/7);
            const arrowLenMaxNonuniform = maxMemberLength * (1/5);

            for (const lid in model.loads) {
                const ld = model.loads[lid];
                if (ld.type === "point") {
                    const nd = model.nodes[ld.node];
                    if (!nd) continue;
                    const sc = modelToScreen(nd.x, nd.y);
                    const fx = ld.values[0];
                    const fy = ld.values[1];
                    
                    // we interpret negative x => arrow left, negative y => arrow down, etc.
                    // arrow length in meters:
                    const arrLenM = arrowLenPointUniform;
                    // convert to screen
                    const arrLenPx = arrLenM * config.scaleFactor;

                    let dx = 0, dy = 0;
                    // x direction
                    if (Math.abs(fx) > 1e-6) {
                        dx = (fx < 0) ? -arrLenPx : arrLenPx;
                    }
                    // y direction
                    if (Math.abs(fy) > 1e-6) {
                        // if negative => arrow is downward on screen
                        dy = (fy < 0) ? arrLenPx : -arrLenPx; 
                        // (remember screen Y is inverted, so negative means up)
                    }
                    const startX = sc.x - dx;
                    const startY = sc.y - dy;

                    drawArrow(startX, startY, sc.x, sc.y, "red");
                    // label
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "red";
                    // show abs value
                    let label = "";
                    if (Math.abs(fx) > 1e-6 && Math.abs(fy) > 1e-6) {
                        label = `${Math.abs(fx)}N, ${Math.abs(fy)}N`;
                    } else if (Math.abs(fx) > 1e-6) {
                        label = `${Math.abs(fx)}N`;
                    } else if (Math.abs(fy) > 1e-6) {
                        label = `${Math.abs(fy)}N`;
                    }
                    ctx.fillText(label, startX, startY);
                }
                else if (ld.type === "uniform") {
                    const mem = model.members[ld.member];
                    if (!mem || mem.type === "truss") continue;
                    const sn = model.nodes[mem.startNode];
                    const en = model.nodes[mem.endNode];
                    if (!sn || !en) continue;
                    const dxm = en.x - sn.x;
                    const dym = en.y - sn.y;
                    const length = Math.sqrt(dxm*dxm + dym*dym);
                    const startS = modelToScreen(sn.x, sn.y);
                    const endS = modelToScreen(en.x, en.y);

                    // arrow length in px for uniform
                    const arrLenPx = arrowLenPointUniform * config.scaleFactor;

                    // The load vector (fx, fy)
                    const fx = ld.values[0];
                    const fy = ld.values[1];

                    // 7 arrows at t=0..1 in steps of 1/6
                    for (let i=0; i<distributedPositions.length; i++){
                        const t = distributedPositions[i];
                        // param in model coords
                        const xM = sn.x + t*dxm;
                        const yM = sn.y + t*dym;
                        const sc = modelToScreen(xM, yM);
                        
                        let ax = 0, ay = 0;
                        if (Math.abs(fx) > 1e-6) {
                            ax = (fx < 0) ? -arrLenPx : arrLenPx;
                        }
                        if (Math.abs(fy) > 1e-6) {
                            ay = (fy < 0) ? arrLenPx : -arrLenPx;
                        }
                        drawArrow(sc.x - ax, sc.y - ay, sc.x, sc.y, "red");
                    }
                    // label near midpoint
                    const midX = sn.x + 0.5*dxm;
                    const midY = sn.y - 0.5*dym;
                    const midS = modelToScreen(midX, midY);
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "red";
                    let label = "";
                    if (Math.abs(fx) > 1e-6 && Math.abs(fy) > 1e-6) {
                        label = `${Math.abs(fx)}N/m, ${Math.abs(fy)}N/m`;
                    } else if (Math.abs(fx) > 1e-6) {
                        label = `${Math.abs(fx)}N/m`;
                    } else if (Math.abs(fy) > 1e-6) {
                        label = `${Math.abs(fy)}N/m`;
                    }
                    ctx.fillText(label, midS.x, midS.y + arrLenPx*Math.sign(fy));
                }
                else if (ld.type === "nonuniform") {
                    const mem = model.members[ld.member];
                    if (!mem || mem.type === "truss") continue;
                    const sn = model.nodes[mem.startNode];
                    const en = model.nodes[mem.endNode];
                    if (!sn || !en) continue;
                    const dxm = en.x - sn.x;
                    const dym = en.y - sn.y;
                    const length = Math.sqrt(dxm*dxm + dym*dym);

                    // arrow length range
                    const minPx = arrowLenMinNonuniform * config.scaleFactor;
                    const maxPx = arrowLenMaxNonuniform * config.scaleFactor;

                    const dir = ld.dir || "y";
                    const startVal = ld.start_val ?? -1000;
                    const endVal = ld.end_val ?? -500;

                    // For 7 arrows
                    for (let i=0; i<distributedPositions.length; i++){
                        const t = distributedPositions[i];
                        const valT = startVal + t*(endVal - startVal); // linear interpolation
                        const absValT = Math.abs(valT);

                        // figure out arrow length in px from min to max
                        // We map [min(absStart,absEnd) -> max(absStart,absEnd)] onto [minPx -> maxPx]
                        const absStart = Math.abs(startVal);
                        const absEnd   = Math.abs(endVal);
                        const dataMin = Math.min(absStart, absEnd);
                        const dataMax = Math.max(absStart, absEnd);
                        const range = Math.max(dataMax - dataMin, 1e-6); // avoid zero
                        const fraction = (absValT - dataMin)/range; // in [0..1]
                        let arrowPx = minPx + fraction*(maxPx - minPx);
                        
                        // Where to place the arrow
                        const xM = sn.x + t*dxm;
                        const yM = sn.y + t*dym;
                        const sc = modelToScreen(xM, yM);

                        // direction
                        let ax = 0, ay = 0;
                        if (dir === "x") {
                            ax = (valT < 0) ? -arrowPx : arrowPx;
                        } else {
                            // negative => arrow downward in screen
                            ay = (valT < 0) ? arrowPx : -arrowPx;
                        }
                        drawArrow(sc.x - ax, sc.y - ay, sc.x, sc.y, "red");
                    }

                    // label near midpoint
                    const midX = sn.x + 0.5*dxm;
                    const midY = sn.y + 0.5*dym;
                    const midS = modelToScreen(midX, midY);
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "red";
                    ctx.fillText(`[${Math.abs(startVal)} -> ${Math.abs(endVal)}] N/m`, midS.x, midS.y + maxPx*Math.sign(startVal));
                }
            }
        }

        function drawArrow(fromX, fromY, toX, toY, color) {
            const headLength = 8;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            // line
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            // arrowhead
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI/6),
                toY - headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI/6),
                toY - headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
        }

        // initial
        updateOptionsVisibility();
        updateModelStats();
        draw();
    </script>
</body>
</html>
