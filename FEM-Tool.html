<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structural FEM Tool</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .sidebar {
            width: 300px;
            background: #e6e6e6;
            padding: 10px;
            overflow-y: auto;
        }
        .canvas-container {
            flex: 1;
            background: #fff;
            position: relative;
        }
        canvas {
            border: 1px solid #ccc;
        }
        h2 {
            margin-top: 0;
        }
        .section {
            margin-top: 10px;
        }
        button {
            margin-right: 5px;
            margin-top: 5px;
        }
        input[type="number"] {
            width: 80px;
        }
        .faded {
            opacity: 0.3;
        }
        .summary {
            margin-top: 10px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left panel -->
        <div class="sidebar">
            <h2>Structural FEM Tool</h2>
            <p><em>By Mohammad Talebi-Kalaleh (talebika@ualberta.ca)</em></p>
            
            <!-- Mode selection -->
            <div class="section">
                <strong>Mode</strong>
                <div>
                    <label><input type="radio" name="mode" value="node" checked> Node</label><br>
                    <label><input type="radio" name="mode" value="member"> Member</label><br>
                    <label><input type="radio" name="mode" value="support"> Support</label><br>
                    <label><input type="radio" name="mode" value="load"> Load</label><br>
                </div>
            </div>
            
            <!-- Member Type -->
            <div class="section member-options">
                <strong>Member Type</strong>
                <div>
                    <label><input type="radio" name="memType" value="beam" checked> Beam</label><br>
                    <label><input type="radio" name="memType" value="truss"> Truss</label><br>
                </div>
            </div>
            
            <!-- Support Type -->
            <div class="section support-options">
                <strong>Support Type</strong>
                <div>
                    <label><input type="radio" name="supportType" value="fixed" checked> Fixed</label><br>
                    <label><input type="radio" name="supportType" value="roller_x"> Roller-X</label><br>
                    <label><input type="radio" name="supportType" value="roller_y"> Roller-Y</label><br>
                    <label><input type="radio" name="supportType" value="hinge"> Hinge</label><br>
                </div>
            </div>
            
            <!-- Load Settings -->
            <div class="section load-options">
                <strong>Load Settings</strong>
                <div>
                    <div>
                        <label><input type="radio" name="loadType" value="point" checked> Point</label><br>
                        <label><input type="radio" name="loadType" value="uniform"> Uniform</label><br>
                        <label><input type="radio" name="loadType" value="nonuniform"> Nonuniform</label><br>
                    </div>
                    <div>
                        <label><input type="radio" name="loadDir" value="x"> X</label><br>
                        <label><input type="radio" name="loadDir" value="y" checked> Y</label><br>
                    </div>
                    
                    <!-- Load Value -->
                    <div id="uniform-load-value">
                        <label>Load Value (N or N/m):</label><br>
                        <input type="number" id="loadValue" value="-1000"><br>
                    </div>
                    
                    <!-- Nonuniform Load Values -->
                    <div id="nonuniform-load-values" style="display: none;">
                        <label>Start Value:</label><br>
                        <input type="number" id="nuStartVal" value="-1000"><br>
                        <label>End Value:</label><br>
                        <input type="number" id="nuEndVal" value="-500"><br>
                    </div>
                    
                    <!-- Grid settings -->
                    <div style="margin-top: 10px;">
                        <label>Grid spacing (meters):</label><br>
                        <select id="gridSpacingSelect">
                            <option value="0.1">0.1 m</option>
                            <option value="0.5">0.5 m</option>
                            <option value="1" selected>1 m</option>
                            <option value="2">2 m</option>
                            <option value="5">5 m</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Grid Settings -->
            <div class="section">
                <strong>Grid Settings</strong><br>
                <label><input type="checkbox" id="isSnap" checked> Grid Snap</label><br>
                <label>Grid spacing (meters):</label><br>
                <select id="gridSpacingSelect">
                    <option value="0.1">0.1 m</option>
                    <option value="0.5">0.5 m</option>
                    <option value="1" selected>1 m</option>
                    <option value="2">2 m</option>
                    <option value="5">5 m</option>
                </select>
            </div>
            
            <!-- Buttons -->
            <div class="section">
                <button id="undoBtn">Undo</button>
                <button id="clearBtn">Clear All</button>
                <button id="saveBtn">Save Model</button>
            </div>
            
            <!-- Summary -->
            <div class="summary">
                <strong>Model Summary</strong>
                <div id="model-stats">
                    Nodes: 0<br>
                    Members: 0<br>
                    Supports: 0<br>
                    Loads: 0
                </div>
            </div>
        </div>
        
        <!-- Canvas area -->
        <div class="canvas-container">
            <canvas id="femCanvas"></canvas>
        </div>
    </div>

    <script>
        // Main model data
        const model = {
            nodes: {},           // { nodeId: { x, y } }
            members: {},         // { memId: { startNode, endNode, type: beam/truss } }
            supports: {},        // { nodeId: { type: fixed/roller_x/roller_y/hinge } }
            loads: {},           // { loadId: { type, node or member, etc. } }
            nodeCounter: 0,
            memberCounter: 0,
            loadCounter: 0
        };

        // Configuration
        const config = {
            mode: "node",         // node | member | support | load
            memberType: "beam",   // beam | truss
            supportType: "fixed", // fixed, roller_x, roller_y, hinge
            loadType: "point",    // point, uniform, nonuniform
            loadDir: "y",         // x | y
            loadValue: -1000,     // for point/uniform
            nuStartVal: -1000,    // for nonuniform start
            nuEndVal: -500,       // for nonuniform end
            isSnap: true,
            gridSpacing: 1,       // in meters
            scaleFactor: 30,      // pixels per meter
            originX: 0,           // X coordinate of origin in screen space
            originY: 0            // Y coordinate of origin in screen space (will be set to canvas.height)
        };

        // Temporary selected node for member creation
        let tempSelectedNode = null;

        // Store the max member length for support size scaling
        let maxMemberLength = 0;

        // History stack for undo
        const history = [];
        const maxHistory = 50;

        // Canvas and context
        const canvas = document.getElementById('femCanvas');
        const ctx = canvas.getContext('2d');
        
        // For cursor coordinates
        let cursorX = 0;
        let cursorY = 0;
        let snappedX = 0;
        let snappedY = 0;

        // Set canvas size and origin
        function resizeCanvas() {
            canvas.width = window.innerWidth - 320;
            canvas.height = window.innerHeight;
            
            // Set origin at bottom right
            config.originX = 50; // Some padding from right edge
            config.originY = canvas.height - 50; // Some padding from bottom edge
            
            // Make sure origin is at a grid point to ensure perfect alignment
            config.originX = Math.round(config.originX / config.scaleFactor) * config.scaleFactor;
            config.originY = Math.round(config.originY / config.scaleFactor) * config.scaleFactor;
            
            draw();
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // UI Element References
        const modeRadios = document.querySelectorAll('input[name="mode"]');
        const memberTypeRadios = document.querySelectorAll('input[name="memType"]');
        const supportTypeRadios = document.querySelectorAll('input[name="supportType"]');
        const loadTypeRadios = document.querySelectorAll('input[name="loadType"]');
        const loadDirRadios = document.querySelectorAll('input[name="loadDir"]');
        const loadValueInput = document.getElementById('loadValue');
        const nuStartValInput = document.getElementById('nuStartVal');
        const nuEndValInput = document.getElementById('nuEndVal');
        const uniformLoadValueDiv = document.getElementById('uniform-load-value');
        const nonuniformLoadValuesDiv = document.getElementById('nonuniform-load-values');
        const isSnapCheckbox = document.getElementById('isSnap');
        const gridSpacingSelect = document.getElementById('gridSpacingSelect');
        const undoBtn = document.getElementById('undoBtn');
        const clearBtn = document.getElementById('clearBtn');
        const saveBtn = document.getElementById('saveBtn');
        const modelStats = document.getElementById('model-stats');

        // Handle mode change opacity
        function updateOptionsVisibility() {
            document.querySelector('.member-options > div').classList.toggle('faded', config.mode !== 'member');
            document.querySelector('.support-options > div').classList.toggle('faded', config.mode !== 'support');
            document.querySelector('.load-options > div').classList.toggle('faded', config.mode !== 'load');
            
            // Disable/enable appropriate inputs
            const memberInputs = document.querySelectorAll('.member-options input');
            memberInputs.forEach(input => {
                input.disabled = config.mode !== 'member';
            });
            
            const supportInputs = document.querySelectorAll('.support-options input');
            supportInputs.forEach(input => {
                input.disabled = config.mode !== 'support';
            });
            
            const loadInputs = document.querySelectorAll('.load-options input');
            loadInputs.forEach(input => {
                input.disabled = config.mode !== 'load';
            });
            
            // Show/hide nonuniform load options
            uniformLoadValueDiv.style.display = config.loadType === 'nonuniform' ? 'none' : 'block';
            nonuniformLoadValuesDiv.style.display = config.loadType === 'nonuniform' ? 'block' : 'none';
        }

        // Calculate max member length (for support size scaling)
        function updateMaxMemberLength() {
            maxMemberLength = 0;
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = mem.startNode;
                const en = mem.endNode;
                if (!model.nodes[sn] || !model.nodes[en]) continue;
                
                const { x: sx, y: sy } = model.nodes[sn];
                const { x: ex, y: ey } = model.nodes[en];
                const dx = ex - sx;
                const dy = ey - sy;
                const length = Math.sqrt(dx*dx + dy*dy);
                
                if (length > maxMemberLength) {
                    maxMemberLength = length;
                }
            }
        }

        // Set up event listeners
        modeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    config.mode = radio.value;
                    updateOptionsVisibility();
                }
            });
        });

        memberTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) config.memberType = radio.value;
            });
        });

        supportTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) config.supportType = radio.value;
            });
        });

        loadTypeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    config.loadType = radio.value;
                    updateOptionsVisibility();
                }
            });
        });

        loadDirRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) config.loadDir = radio.value;
            });
        });

        loadValueInput.addEventListener('change', () => {
            config.loadValue = parseFloat(loadValueInput.value) || -1000;
        });

        nuStartValInput.addEventListener('change', () => {
            config.nuStartVal = parseFloat(nuStartValInput.value) || -1000;
        });

        nuEndValInput.addEventListener('change', () => {
            config.nuEndVal = parseFloat(nuEndValInput.value) || -500;
        });

        isSnapCheckbox.addEventListener('change', () => {
            config.isSnap = isSnapCheckbox.checked;
            draw();
        });

        gridSpacingSelect.addEventListener('change', () => {
            const value = parseFloat(gridSpacingSelect.value);
            if (!isNaN(value) && value > 0) {
                config.gridSpacing = value;
                draw();
            }
        });

        undoBtn.addEventListener('click', handleUndo);
        clearBtn.addEventListener('click', handleClear);
        saveBtn.addEventListener('click', handleSave);

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            // Snap coordinates only if snap is enabled
            if (config.isSnap) {
                x = snapCoord(x);
                y = snapCoord(y, true);
            }
            
            handleCanvasClick(x, y);
        });
        
        // Track mouse movement for coordinates display
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            cursorX = e.clientX - rect.left;
            cursorY = e.clientY - rect.top;
            
            // Show snapped position in display if snap is enabled
            if (config.isSnap) {
                snappedX = snapCoord(cursorX);
                snappedY = snapCoord(cursorY, true);
            } else {
                snappedX = cursorX;
                snappedY = cursorY;
            }
            
            draw(); // Redraw to update coordinate display
        });


        // Initialize visibility
        updateOptionsVisibility();

        // Helper Functions
        function pushHistory() {
            const snapshot = JSON.parse(JSON.stringify(model));
            history.push(snapshot);
            if (history.length > maxHistory) history.shift();
        }

        function popHistory() {
            if (history.length === 0) {
                console.log("Nothing to undo");
                return;
            }
            const last = history.pop();
            Object.assign(model, last);
            tempSelectedNode = null;
            updateMaxMemberLength();
            updateModelStats();
            draw();
        }

        // Convert from screen coordinates to model coordinates (meters)
        function screenToModel(screenX, screenY) {
            return {
                x: (screenX - config.originX) / config.scaleFactor,
                y: (config.originY - screenY) / config.scaleFactor // Y inverted for screen coordinates
            };
        }
        
        // Convert from model coordinates (meters) to screen coordinates
        function modelToScreen(modelX, modelY) {
            return {
                x: config.originX + modelX * config.scaleFactor,
                y: config.originY - modelY * config.scaleFactor // Y inverted for screen coordinates
            };
        }
        
        function snapCoord(screenVal, isY = false) {
            if (!config.isSnap) return screenVal;
            
            // Convert to model coordinates
            let modelVal;
            if (isY) {
                modelVal = (config.originY - screenVal) / config.scaleFactor;
            } else {
                modelVal = (screenVal - config.originX) / config.scaleFactor;
            }
            
            // Snap in model space to exact grid points
            const snappedModelVal = Math.round(modelVal / config.gridSpacing) * config.gridSpacing;
            
            // Convert back to screen coordinates
            if (isY) {
                return config.originY - snappedModelVal * config.scaleFactor;
            } else {
                return config.originX + snappedModelVal * config.scaleFactor;
            }
        }

        function findClosestNode(x, y, tolerance = 10) {
            let closest = null;
            let minDist = Infinity;
            for (const nid in model.nodes) {
                const nd = model.nodes[nid];
                const dx = nd.x - x;
                const dy = nd.y - y;
                const d2 = dx*dx + dy*dy;
                if (d2 < minDist) {
                    minDist = d2;
                    closest = nid;
                }
            }
            if (Math.sqrt(minDist) < tolerance) return closest;
            return null;
        }

        function pointToLineDist(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len2 = dx*dx + dy*dy;
            if (len2 === 0) {
                // segment is a point
                const dx2 = px - x1;
                const dy2 = py - y1;
                return Math.sqrt(dx2*dx2 + dy2*dy2);
            }
            let t = ((px - x1)*dx + (py - y1)*dy)/len2;
            t = Math.max(0, Math.min(1, t));
            const cx = x1 + t*dx;
            const cy = y1 + t*dy;
            const dx3 = px - cx;
            const dy3 = py - cy;
            return Math.sqrt(dx3*dx3 + dy3*dy3);
        }

        function findClosestMember(x, y, tolerance=10) {
            let closest = null;
            let minDist = Infinity;
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = mem.startNode;
                const en = mem.endNode;
                if (!model.nodes[sn] || !model.nodes[en]) continue;
                const { x: sx, y: sy } = model.nodes[sn];
                const { x: ex, y: ey } = model.nodes[en];
                const d = pointToLineDist(x, y, sx, sy, ex, ey);
                if (d < minDist) {
                    minDist = d;
                    closest = mid;
                }
            }
            if (minDist < tolerance) return closest;
            return null;
        }

        function updateModelStats() {
            modelStats.innerHTML = `
                Nodes: ${Object.keys(model.nodes).length}<br>
                Members: ${Object.keys(model.members).length}<br>
                Supports: ${Object.keys(model.supports).length}<br>
                Loads: ${Object.keys(model.loads).length}
            `;
        }

        // Main click handler
        function handleCanvasClick(x, y) {
            x = snapCoord(x);
            y = snapCoord(y);

            if (config.mode === "node") {
                // add node
                pushHistory();
                const newNodeId = "N" + (model.nodeCounter+1);
                model.nodeCounter++;
                model.nodes[newNodeId] = { x, y };
            }
            else if (config.mode === "member") {
                // find closest node
                const nid = findClosestNode(x, y);
                if (!nid) {
                    console.log("No node near click (member).");
                    return;
                }
                if (!tempSelectedNode) {
                    tempSelectedNode = nid;
                } else {
                    if (nid !== tempSelectedNode) {
                        // create member
                        pushHistory();
                        const newMemId = "M" + (model.memberCounter+1);
                        model.memberCounter++;
                        model.members[newMemId] = {
                            startNode: tempSelectedNode,
                            endNode: nid,
                            type: config.memberType
                        };
                        updateMaxMemberLength(); // Update max member length
                    }
                    tempSelectedNode = null;
                }
            }
            else if (config.mode === "support") {
                // find node
                const nid = findClosestNode(x, y);
                if (!nid) return;
                pushHistory();
                model.supports[nid] = { type: config.supportType };
            }
            else if (config.mode === "load") {
                if (config.loadType === "point") {
                    // find node
                    const nid = findClosestNode(x, y);
                    if (!nid) return;
                    pushHistory();
                    const newLid = "L" + (model.loadCounter+1);
                    let vals = [0,0];
                    if (config.loadDir === "x") vals = [config.loadValue, 0];
                    else vals = [0, config.loadValue];
                    model.loadCounter++;
                    model.loads[newLid] = {
                        type: "point",
                        node: nid,
                        values: vals
                    };
                }
                else if (config.loadType === "uniform" || config.loadType === "nonuniform") {
                    // find member
                    const mid = findClosestMember(x, y);
                    if (!mid) return;
                    // if member is truss => skip distributed
                    if (model.members[mid].type === "truss") {
                        console.log("Cannot assign distributed load on truss.");
                        return;
                    }
                    pushHistory();
                    const newLid = "L" + (model.loadCounter+1);
                    model.loadCounter++;
                    if (config.loadType === "uniform") {
                        let vals = [0,0];
                        if (config.loadDir === "x") vals = [config.loadValue, 0];
                        else vals = [0, config.loadValue];
                        model.loads[newLid] = {
                            type: "uniform",
                            member: mid,
                            values: vals,
                            span: [0,1]
                        };
                    } else {
                        model.loads[newLid] = {
                            type: "nonuniform",
                            member: mid,
                            start_val: config.nuStartVal,
                            end_val: config.nuEndVal,
                            span: [0,1],
                            dir: config.loadDir
                        };
                    }
                }
            }
            
            updateModelStats();
            draw();
        }

        // Action Functions
        function handleUndo() {
            popHistory();
        }

        function handleClear() {
            pushHistory();
            model.nodes = {};
            model.members = {};
            model.supports = {};
            model.loads = {};
            model.nodeCounter = 0;
            model.memberCounter = 0;
            model.loadCounter = 0;
            tempSelectedNode = null;
            maxMemberLength = 0;
            updateModelStats();
            draw();
        }

        function handleSave() {
            const exportData = {
                nodes: model.nodes,
                members: model.members,
                supports: model.supports,
                loads: model.loads
            };
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "structural_model.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        // Drawing Functions
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            if (config.isSnap) {
                drawGrid();
            }
            
            // Draw members
            drawMembers();
            
            // Draw nodes
            drawNodes();
            
            // Draw supports
            drawSupports();
            
            // Draw loads
            drawLoads();
            
            // Draw temp selection for member creation
            if (tempSelectedNode && config.mode === "member") {
                const nd = model.nodes[tempSelectedNode];
                if (nd) {
                    ctx.beginPath();
                    ctx.strokeStyle = "orange";
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.arc(nd.x, nd.y, 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Draw cursor coordinates in bottom right
            drawCursorCoordinates();
        }
        
        // Draw cursor coordinates
        function drawCursorCoordinates() {
            const padding = 10;
            const boxHeight = 20;
            
            // Convert screen coordinates to model coordinates (meters)
            const modelCoords = screenToModel(snappedX, snappedY);
            const modelX = modelCoords.x.toFixed(2);
            const modelY = modelCoords.y.toFixed(2);
            
            const coords = `(${modelX}m, ${modelY}m)`;
            
            ctx.font = "12px Arial";
            const textWidth = ctx.measureText(coords).width;
            
            // Draw background
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(
                canvas.width - textWidth - padding * 2,
                canvas.height - boxHeight - padding,
                textWidth + padding * 2,
                boxHeight
            );
            
            // Draw text
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(
                coords,
                canvas.width - textWidth/2 - padding,
                canvas.height - padding - 4
            );
            ctx.textAlign = "left"; // Reset to default
        }

        function drawGrid() {
            ctx.save();
            
            // Calculate model coordinates of the visible area corners
            const topLeft = screenToModel(0, 0);
            const bottomRight = screenToModel(canvas.width, canvas.height);
            
            // Calculate grid line ranges
            const xStart = Math.floor(topLeft.x / config.gridSpacing) * config.gridSpacing;
            const xEnd = Math.ceil(bottomRight.x / config.gridSpacing) * config.gridSpacing;
            const yStart = Math.floor(bottomRight.y / config.gridSpacing) * config.gridSpacing; // Bottom of screen
            const yEnd = Math.ceil(topLeft.y / config.gridSpacing) * config.gridSpacing; // Top of screen
            
            // Draw minor grid lines (lighter)
            ctx.strokeStyle = "#e0e0e0";
            ctx.lineWidth = 0.5;
            
            // Draw minor vertical grid lines
            for (let x = xStart; x <= xEnd; x += config.gridSpacing) {
                const screenX = modelToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Draw minor horizontal grid lines
            for (let y = yStart; y <= yEnd; y += config.gridSpacing) {
                const screenY = modelToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
            
            // Draw major grid lines (every 5 units, darker)
            const majorSpacing = Math.max(5 * config.gridSpacing, 1);
            ctx.strokeStyle = "#d0d0d0";
            ctx.lineWidth = 0.8;
            
            // Draw major vertical grid lines
            for (let x = Math.floor(xStart / majorSpacing) * majorSpacing; x <= xEnd; x += majorSpacing) {
                const screenX = modelToScreen(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            // Draw major horizontal grid lines
            for (let y = Math.floor(yStart / majorSpacing) * majorSpacing; y <= yEnd; y += majorSpacing) {
                const screenY = modelToScreen(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
            
            // Draw axis lines (thickest)
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 1.5;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, config.originY);
            ctx.lineTo(canvas.width, config.originY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(config.originX, 0);
            ctx.lineTo(config.originX, canvas.height);
            ctx.stroke();
            
            // Draw grid labels
            ctx.font = "12px Arial";
            
            // Draw X-axis labels
            for (let x = xStart; x <= xEnd; x += config.gridSpacing) {
                if (Math.abs(x) < 0.001) continue; // Skip origin
                
                const screenX = modelToScreen(x, 0).x;
                
                // Major labels (larger, darker)
                if (Math.abs(x % majorSpacing) < 0.001) {
                    ctx.fillStyle = "#222";
                    ctx.textAlign = "center";
                    ctx.fillText(`${x.toFixed(0)}m`, screenX, config.originY + 20);
                }
                // Minor labels (smaller, lighter)
                else if (config.gridSpacing >= 0.5) { // Only show minor labels if grid is not too dense
                    ctx.fillStyle = "#777";
                    ctx.textAlign = "center";
                    ctx.font = "10px Arial";
                    ctx.fillText(`${x.toFixed(1)}`, screenX, config.originY + 15);
                }
            }
            
            // Draw Y-axis labels
            for (let y = yStart; y <= yEnd; y += config.gridSpacing) {
                if (Math.abs(y) < 0.001) continue; // Skip origin
                
                const screenY = modelToScreen(0, y).y;
                
                // Major labels (larger, darker)
                if (Math.abs(y % majorSpacing) < 0.001) {
                    ctx.fillStyle = "#222";
                    ctx.textAlign = "right";
                    ctx.fillText(`${y.toFixed(0)}m`, config.originX - 10, screenY + 4);
                }
                // Minor labels (smaller, lighter)
                else if (config.gridSpacing >= 0.5) { // Only show minor labels if grid is not too dense
                    ctx.fillStyle = "#777";
                    ctx.textAlign = "right";
                    ctx.font = "10px Arial";
                    ctx.fillText(`${y.toFixed(1)}`, config.originX - 5, screenY + 3);
                }
            }
            
            // Draw origin label
            ctx.fillStyle = "#000";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "left";
            ctx.fillText("(0,0)", config.originX + 5, config.originY - 5);
            
            // Draw grid spacing indicator in top-left
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(10, 10, 160, 30);
            ctx.fillStyle = "white";
            ctx.font = "14px Arial";
            ctx.textAlign = "left";
            ctx.fillText(`Grid Spacing: ${config.gridSpacing}m`, 20, 30);
            
            // Draw X and Y axis labels
            ctx.fillStyle = "#333";
            ctx.font = "bold 14px Arial";
            
            // X-axis label
            ctx.textAlign = "center";
            ctx.fillText("X (m)", canvas.width / 2, config.originY + 40);
            
            // Y-axis label (rotated)
            ctx.save();
            ctx.translate(config.originX - 40, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("Y (m)", 0, 0);
            ctx.restore();
            
            ctx.restore();
        }

        function drawNodes() {
            for (const nid in model.nodes) {
                const nd = model.nodes[nid];
                
                // Draw node circle
                ctx.beginPath();
                ctx.fillStyle = "#1a75ff";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;
                ctx.arc(nd.x, nd.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Draw node label
                ctx.font = "14px Arial";
                ctx.fillStyle = "black";
                ctx.fillText(nid, nd.x + 8, nd.y + 8);
            }
        }

        function drawMembers() {
            for (const mid in model.members) {
                const mem = model.members[mid];
                const sn = mem.startNode;
                const en = mem.endNode;
                if (!model.nodes[sn] || !model.nodes[en]) continue;
                
                const { x: sx, y: sy } = model.nodes[sn];
                const { x: ex, y: ey } = model.nodes[en];
                const color = (mem.type === "beam") ? "#006633" : "blue";
                
                // Draw member line
                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.moveTo(sx, sy);
                ctx.lineTo(ex, ey);
                ctx.stroke();
                
                    // Draw member label at midpoint
                const mx = (sx + ex) / 2;
                const my = (sy + ey) / 2;
                
                ctx.font = "12px Arial";
                ctx.fillStyle = "#000";
                // Add a small white background for better readability
                const textWidth = ctx.measureText(mid).width;
                ctx.fillStyle = "rgba(255,255,255,0.7)";
                ctx.fillRect(mx - textWidth/2 - 2, my - 8, textWidth + 4, 16);
                
                ctx.fillStyle = "#000";
                ctx.textAlign = "center";
                ctx.fillText(mid, mx, my);
                ctx.textAlign = "left"; // Reset to default
            }
        }

        function drawSupports() {
            // Calculate the support size based on max member length
            // Support size will be 1/5 of max member length or a minimum size
            const supportSize = Math.max(20, maxMemberLength / 5);
            
            for (const node_id in model.supports) {
                if (!model.nodes[node_id]) continue;
                
                const st = model.supports[node_id].type;
                const { x, y } = model.nodes[node_id];
                const fill = "purple";
                
                switch(st) {
                    case "fixed":
                        // Draw hatched gray square
                        const squareSize = supportSize;
                        ctx.fillStyle = "#888";
                        ctx.fillRect(x - squareSize/2, y - squareSize/2, squareSize, squareSize);
                        
                        // Add hatching pattern
                        ctx.strokeStyle = "#444";
                        ctx.lineWidth = 1;
                        
                        // Horizontal hatching
                        const hatchSpacing = squareSize / 8;
                        for (let i = -squareSize/2; i <= squareSize/2; i += hatchSpacing) {
                            ctx.beginPath();
                            ctx.moveTo(x - squareSize/2, y + i);
                            ctx.lineTo(x + squareSize/2, y + i);
                            ctx.stroke();
                        }
                        
                        // Vertical hatching
                        for (let i = -squareSize/2; i <= squareSize/2; i += hatchSpacing) {
                            ctx.beginPath();
                            ctx.moveTo(x + i, y - squareSize/2);
                            ctx.lineTo(x + i, y + squareSize/2);
                            ctx.stroke();
                        }
                        break;
                        
                    case "roller_x":
                        // Large triangle pointing left
                        ctx.fillStyle = fill;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x-supportSize, y-supportSize/2);
                        ctx.lineTo(x-supportSize, y+supportSize/2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case "roller_y":
                        // Large triangle pointing up
                        ctx.fillStyle = fill;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x-supportSize/2, y-supportSize);
                        ctx.lineTo(x+supportSize/2, y-supportSize);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case "hinge":
                        // Combine roller_x and roller_y
                        ctx.fillStyle = fill;
                        
                        // Left-pointing triangle
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x-supportSize, y-supportSize/2);
                        ctx.lineTo(x-supportSize, y+supportSize/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Up-pointing triangle
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x-supportSize/2, y-supportSize);
                        ctx.lineTo(x+supportSize/2, y-supportSize);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
            }
        }

        function drawLoads() {
            for (const lid in model.loads) {
                const ld = model.loads[lid];
                
                if (ld.type === "point") {
                    const { node, values } = ld;
                    if (!model.nodes[node]) continue;
                    
                    const { x, y } = model.nodes[node];
                    const [fx, fy] = values;
                    
                    // Arrow parameters
                    const arrowLength = 40;
                    let dx=0, dy=0;
                    
                    // X direction arrow (positive value, but direction based on sign)
                    if (Math.abs(fx) > 0.01) {
                        dx = Math.sign(fx) * arrowLength;
                    }
                    
                    // Y direction arrow (positive value, but direction based on sign)
                    if (Math.abs(fy) > 0.01) {
                        dy = Math.sign(fy) * arrowLength;
                    }
                    
                    const startX = x - dx;
                    const startY = y - dy;
                    const color = "red";
                    
                    // Draw arrow
                    drawArrow(startX, startY, x, y, color);
                    
                    // Draw label with positive values and units
                    ctx.font = "12px Arial";
                    ctx.fillStyle = color;
                    
                    let label = "";
                    if (Math.abs(fx) > 0.01 && Math.abs(fy) > 0.01) {
                        // Both X and Y loads
                        label = `${Math.abs(fx)}N, ${Math.abs(fy)}N`;
                    } else if (Math.abs(fx) > 0.01) {
                        // Only X load
                        label = `${Math.abs(fx)}N`;
                    } else if (Math.abs(fy) > 0.01) {
                        // Only Y load
                        label = `${Math.abs(fy)}N`;
                    }
                    
                    ctx.fillText(label, startX, startY - 5);
                }
                else if (ld.type === "uniform" || ld.type === "nonuniform") {
                    const memId = ld.member;
                    if (!model.members[memId]) continue;
                    if (model.members[memId].type === "truss") continue;
                    
                    const sn = model.members[memId].startNode;
                    const en = model.members[memId].endNode;
                    if (!model.nodes[sn] || !model.nodes[en]) continue;
                    
                    const { x: sx, y: sy } = model.nodes[sn];
                    const { x: ex, y: ey } = model.nodes[en];
                    
                    // Calculate member properties
                    const dx = ex - sx;
                    const dy = ey - sy;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // Direction perpendicular to member
                    const perpAngle = angle - Math.PI/2;
                    
                    if (ld.type === "uniform") {
                        const [fx, fy] = ld.values || [0, 0];
                        const color = "red";
                        
                        // Number of arrows for distributed load
                        const numArrows = Math.max(3, Math.floor(length / 50));
                        
                        // Arrow size and direction
                        const arrowLength = 20;
                        let arrowDx = 0, arrowDy = 0;
                        
                        // Set direction based on sign, but label will show positive value
                        if (Math.abs(fx) > 0.01) {
                            arrowDx = Math.sign(fx) * arrowLength;
                        } else if (Math.abs(fy) > 0.01) {
                            arrowDy = Math.sign(fy) * arrowLength;
                        }
                        
                        // Draw multiple arrows along the member
                        for (let i = 0; i <= numArrows; i++) {
                            const t = i / numArrows;
                            const arrowX = sx + t * dx;
                            const arrowY = sy + t * dy;
                            
                            // Start point for arrow
                            const startX = arrowX - arrowDx;
                            const startY = arrowY - arrowDy;
                            
                            // Draw arrow
                            drawArrow(startX, startY, arrowX, arrowY, color);
                        }
                        
                        // Draw label at midpoint
                        const mx = (sx + ex) / 2;
                        const my = (sy + ey) / 2;
                        const labelX = mx - arrowDx;
                        const labelY = my - arrowDy - 5;
                        
                        // Show positive value with units
                        let label = "";
                        if (Math.abs(fx) > 0.01 && Math.abs(fy) > 0.01) {
                            // Both X and Y loads
                            label = `${Math.abs(fx)}N/m (x), ${Math.abs(fy)}N/m (y)`;
                        } else if (Math.abs(fx) > 0.01) {
                            // Only X load
                            label = `${Math.abs(fx)}N/m`;
                        } else if (Math.abs(fy) > 0.01) {
                            // Only Y load
                            label = `${Math.abs(fy)}N/m`;
                        }
                        
                        ctx.font = "12px Arial";
                        ctx.fillStyle = color;
                        ctx.fillText(label, labelX, labelY);
                    } else {
                        // Nonuniform load
                        const startVal = ld.start_val ?? -1000;
                        const endVal = ld.end_val ?? -500;
                        const dir = ld.dir || "y";
                        const color = "red";
                        
                        // Number of arrows for distributed load
                        const numArrows = Math.max(3, Math.floor(length / 50));
                        
                        // Draw multiple arrows along the member with varying sizes
                        for (let i = 0; i <= numArrows; i++) {
                            const t = i / numArrows;
                            const arrowX = sx + t * dx;
                            const arrowY = sy + t * dy;
                            
                            // Interpolate arrow length based on position
                            const val = startVal + t * (endVal - startVal);
                            const arrowLength = Math.max(10, Math.min(40, Math.abs(val) / 100));
                            
                            // Arrow direction based on sign, but value will be positive
                            let arrowDx = 0, arrowDy = 0;
                            if (dir === "x") {
                                arrowDx = Math.sign(val) * arrowLength;
                            } else {
                                arrowDy = Math.sign(val) * arrowLength;
                            }
                            
                            // Start point for arrow
                            const startX = arrowX - arrowDx;
                            const startY = arrowY - arrowDy;
                            
                            // Draw arrow
                            drawArrow(startX, startY, arrowX, arrowY, color);
                        }
                        
                        // Draw label at midpoint
                        const mx = (sx + ex) / 2;
                        const my = (sy + ey) / 2;
                        
                        // Show positive values with units
                        ctx.font = "12px Arial";
                        ctx.fillStyle = color;
                        ctx.fillText(`[${Math.abs(startVal)}->${Math.abs(endVal)}]N/m`, mx, my - 15);
                    }
                }
            }
        }

        function drawArrow(fromX, fromY, toX, toY, color) {
            const headLength = 8;    // Length of arrow head
            const headWidth = 8;     // Width of arrow head
            
            // Calculate arrow direction
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            
            // Draw line
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // Draw arrowhead
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI/6),
                toY - headLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI/6),
                toY - headLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
        }

        // Initial draw
        draw();
    </script>
</body>
</html>
